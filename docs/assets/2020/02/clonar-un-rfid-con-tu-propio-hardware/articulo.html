<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
<link rel="stylesheet" href="../../../resources/style.css">
<script src="../../../resources/script.js">
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' type='text/javascript'>
MathJax.Hub.Config({
 extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
 jax: ["input/TeX", "output/HTML-CSS"],
 tex2jax: {
     inlineMath: [ ['$','$'], ['$$','$$'], ["\\(","\\)"] ],
     displayMath: [ ["\\[","\\]"] ],
 },
 "HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<title>Clonar un RFID con tu propio hardware</title>
</head>
<body>
<div class="content-outer">
<div class="header">
<div class="title">
<h1>Electrónica y Ciencia</h1>
</div><!-- title -->
<div class="description">
<h2>Blog técnico sobre proyectos caseros de electrónica, informática y física.</h2>
</div><!-- description -->
</div><!-- header -->
<div class="content-inner">
<!-- Here the blog content -->
<h3 class='post-title entry-title'>Clonar un RFID con tu propio hardware</h3>
<div class='post-date'>
Publicado el 23-02-2020.
</div>
<div class='post-body entry-content'>
En el <a href="../../../2019/12/leer-tarjetas-de-acceso-rfid-sin-arduino/articulo.html">artículo anterior</a> tratamos sobre leer tarjetas de proximidad. Y acabamos diciendo lo fácil que es copiar las más básicas.<br>
<br>
En este artículo vamos a <b>experimentar</b> con RFID de <b>baja frecuencia</b> (125kHz). Haremos nuestro propio lector/grabador usando un microcontrolador y algunos componentes discretos. Diseñaremos la electrónica, el firmware y el software para hablar con un chip regrabable.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/yellow_fob.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="994" data-original-width="1600" src="img/yellow_fob.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">El llavero de la derecha no tiene número, puede hacerse pasar por los otros dos chips.</td>
</tr>
</tbody>
</table><br>
Una cosa más: este es un blog técnico. Si tu única intención es copiar tarjetas, un <a href="https://www.ebay.com/sch/i.html?_nkw=RFID+125KHz+Copier">clonador chino</a> vale $7.45 y sólo tiene dos botones. No necesitas seguir leyendo, sabrás usarlo.<br>
<br>
<br>
<a name='more' id="more"></a><br>
El proceso de clonar un identificador tiene cuatro pasos:<br>
<br>
<b>Primero</b>, caracterizar el mensaje: tamaño, velocidad, modulación, etc. Lógicamente, para emularlo necesitaremos un chip capaz de transmitir de igual modo. Por ejemplo, el mensaje del EM4100 consta de 64 bits transmitidos en ASK con codificación Manchester.<br>
<br>
<b>Segundo</b>, registrar el mensaje. El EM4100 transmite siempre los mismos bits en bucle. Fácil de imitar. En algunos chips el lector envía un desafío y la respuesta se basa en una operación con áreas de memoria no legibles. Mucho más complicado emularlo. Pero no es el caso del EM4100. Por eso esta tecnología está obsoleta y no debería usarse como control de acceso.<br>
<br>
<b>Tercero</b>, escribir el mensaje en un chip. Usaremos un chip regrabable. Aunque un microcontrolador puede actuar también como tag RFID (<a href="https://hackaday.com/2011/09/26/barebones-pic-rfid-tag/">Barebones PIC RFID tag</a>).<br>
<br>
Y <b>cuarto</b>, configurar los parámetros adecuados. Los que habíamos identificado en el paso uno.<br>
<br>
<br>
Hay dos familias de chips regrabables: el <b>T5577</b> y el <b>EM4305</b> (y compatibles con ellos). El T5577 es muy completo y versátil. Más caro, pero prácticamente universal. El proyecto <a href="http://www.proxmark.org/">Proxmark3</a>, por ejemplo, sólo soporta ese chip. En la práctica, la diferencia más importante es que el T5577 permite lo mismo que el EM4305 y, además, modulación de frecuencia (FSK). Así podríamos imitar incluso la última tarjeta que vimos, la HID.<br>
<br>
El EM4305 es más simple. Su datasheet tiene 19 páginas frente a las 47 páginas del T5577. Nos basta con él y es más sencillo de operar. Y como los protocolos de uno y otro son incompatibles, a partir de ahora me centraré en éste.<br>
<br>
<br>
<b>El EM4305</b><br>
<br>
Aquí tenéis el <a href="http://www.emmicroelectronic.com/sites/default/files/products/datasheets/4205-4305-DS-01.pdf">datasheet</a>. Lo leemos buscando la respuesta a tres preguntas: ¿Cómo nos comunicamos con él? ¿Cómo grabamos un mensaje? ¿Cómo configuramos la velocidad y modulación?<br>
<br>
El fabricante nos presenta este chip enumerando sus características. Dice que tiene 16 registros de 32 bits de memoria. Identificador único de 32 bits, protección por contraseña, bloqueo de escritura, compatible con los estándares de identificación animal, etc. Desde nuestro punto de vista lo más importante es:<br>
<ul>
<li>512 bit EEPROM organized in 16 words of 32 bit</li>
<li>Two data encodings: Manchester and Bi-phase</li>
<li>Multi-purpose data rate: 8, 16, 32, 40 and 64 RF clocks</li>
<li>100 to 150 kHz frequency range</li>
</ul>Sólo 9 de los 16 registros (del 5 al 13) sirven, de hecho, para grabar mensajes. El resto son para identificación, password y otras funciones.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/em4205_memory.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="498" data-original-width="818" src="img/em4205_memory.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Registros del EM4305. Sólo del 4 al 8 son relevantes para este artículo.</td>
</tr>
</tbody>
</table><br>
El <b>registro 4</b> es el de <b>configuración</b>. Ahí se pone si la modulación la queremos Manchester o Biphase. También la velocidad, indicada en periodos del campo magnético (125 kHz). El valor por defecto es RF/32, significa que cada bit dura 32 periodos (256µs). Dato importante más adelante.<br>
<br>
Como curiosidad, hay un bit de configuración llamado <em>pigeon mode</em>. Sirve para fijar unos parámetros concretos, bloquea ciertos bits y deja libres otros. Al parecer, un destino importante de estos chips es el control de tiempo en <a href="https://es.wikipedia.org/wiki/Carrera_de_palomas#M%C3%A9todo_de_cronometraje_electr%C3%B3nico">carreras de palomas</a> mensajeras.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/em4305-pigeon-foot-rings.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="468" data-original-width="612" src="img/em4305-pigeon-foot-rings.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">El EM4305 se usa en carreras de palomas mensajeras. Fuente Aliexpress.</td>
</tr>
</tbody>
</table><br>
El datasheet nos habla también de cinco comandos, entre ellos <b>read</b> y <b>write</b> para leer y escribir valores en los registros.<br>
<br>
Nos describe la comunicación con el chip (también llamado <em>transpondedor</em>). Diferenciando entre comunicación de subida (lector-chip) y de bajada (chip-lector) por lo que entendemos que son distintas.<br>
<br>
El EM4100 emitía un mensaje nada más acercarlo al lector. El EM4305 hace lo mismo. Se llama modo <b>default read</b> y consiste en transmitir en bucle los bits almacenados en los registros 5 al 13. Y eso es lo que hará hasta que lo interrumpimos enviándole algún comando.<br>
<br>
Enviar comandos consiste en cortar el campo magnético en momentos oportunos. Los detalles los veremos más adelante.<br>
<br>
Respondiendo a las preguntas del principio: <em>¿Cómo nos comunicamos con él?</em> Interrumpiendo el campo magnético a intervalos. <em>¿Cómo grabamos un mensaje?</em> Con el comando write. <em>¿Cómo configuramos la velocidad y modulación?</em> Escribiendo en el registro de configuración.<br>
<br>
<br>
<br>
<b>Hardware</b><br>
<br>
El <a href="https://www.emmicroelectronic.com/sites/default/files/products/datasheets/em4095_ds.pdf">EM4095</a> es un integrado especialmente diseñado para interactuar con el EM4305 y similares. Es muy sencillo de usar. Tan sólo requiere antena, algunos componentes y un microcontrolador. Paso. Me quedo con el microcontrolador sólo.<br>
<br>
En estos proyectos de baja frecuencia la velocidad de transferencia también es baja. RF/32 por ejemplo son 4kHz. Se puede procesar en un microcontrolador de propósito general. Para jugar con velocidades no mucho mayores ya necesitaríamos un DSP.<br>
<br>
Buscamos un circuito que excite una bobina con una frecuencia de 125kHz, pueda interrumpa el campo cada cierto tiempo (µs), recoja las variaciones en la amplitud y las transforme en señales digitales. A mi se me ocurre el siguiente esquema: un microcontrolador, una etapa excitadora para la bobina y un detector de envolvente como demodulador AM.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/main_schematic_texture.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="805" data-original-width="1506" src="img/main_schematic_texture.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Esquema principal. Click para ampliar.</td>
</tr>
</tbody>
</table><br>
No es tan bueno como uno comercial, el rango de lectura es menor y a veces falla. Pero cumplirá su objetivo: servir como <em>herramienta</em> para aprender cómo funciona uno de estos chips.<br>
<br>
Empezamos por el microcontrolador, un <b>PIC12F683</b>. Por razones que no vienen al caso, los PIC se usan más en la industria que entre aficionados. Aunque a mi, personalmente, me parecen muy prácticos en proyectos sencillos. Sobre todo el 12F683. Con 8 patillas tiene oscilador interno de 8MHz, ADC, módulo PWM, comparador, temporizadores, EEPROM, etc. y es fácil de encontrar.<br>
<br>
8 MHz puede parecer mucha velocidad frente a los 125 kHz con que trabajaremos, pero si lo pensáis no es tanto. Tened en cuenta que cada instrucción de PIC lleva 4 ciclos de reloj, además el juego de instrucciones RISC no es especialmente eficiente y para colmo, no voy a programarlo en ensamblador sino en C.<br>
<br>
Con el módulo <b>PWM</b> generamos la onda cuadrada de 125 kHz. Sale por su <b>patilla 5</b> hacia la etapa de salida AB compuesta por <b>Q2</b> y <b>Q3</b>, cuyo funcionamiento explicamos ya en <a href="../../../2019/12/leer-tarjetas-de-acceso-rfid-sin-arduino/articulo.html">Leer tarjetas de acceso RFID, sin Arduino</a>. <b>L</b> es la bobina que actúa de <b>antena</b> RFID. Debe formar con <b>C2</b> un circuito resonante, por lo que la capacidad del condensador se calcula en función de <b>L</b> y la frecuencia exacta.<br>
<br>
<b>D3</b>, <b>C3</b> y <b>R7</b> forman un detector de envolvente; la forma más fácil (no la mejor) de demodular una señal modulada en amplitud. Es imprescindible añadir un filtro paso alto formado por <b>C4</b> y <b>R9</b>. Dicho filtro bloquea la tensión en la unión LC -que puede alcanzar decenas de voltios- y deja pasar sólo las variaciones. Ahora tenemos la señal centrada en 0. Para facilitar su detección sumamos una tensión positiva mediante <b>R9</b> .<br>
<br>
El valor de <b>C4</b> es crítico y depende de la velocidad de transmisión usada: si es muy grande, el filtro será muy lento. Afectará negativamente a la recepción de mensajes a velocidades altas (RF/16). La tensión presente en LC podría llegar a dañar el micro. Por el contrario, si <b>C4</b> es muy pequeño, la respuesta del filtro será rápida. Pero atenuará mucho los pulsos de velocidades más lentas (RF/64). Un diseño sencillo siempre tiene limitaciones prácticas.<br>
<br>
<b>C1</b> estabiliza la tensión en el integrado frente a posibles picos de consumo. Es bueno colocar un segundo condensador de, por ejemplo, 10nF en paralelo con él y lo más cercano posible al PIC. Así filtraremos el ruido de frecuencias altas.<br>
<br>
Por último, los pines <b>Rx</b> y <b>Tx</b> van al PC vía un conversor USB-Serie.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/bread_board.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="776" data-original-width="1458" src="img/bread_board.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">El circuito anterior construido sobre una protoboard.</td>
</tr>
</tbody>
</table><br>
<br>
<br>
<b>Protocolo físico</b><br>
<br>
Al igual que cuando tratamos <a href="../../../2016/12/el-bus-1-wire-bajo-nivel/articulo.html">el bus 1-Wire a bajo nivel</a> o <a href="../../../2017/02/el-bus-i2c-bajo-nivel/articulo.html">el bus I2C a bajo nivel</a>, en el fondo todo se reduce a saber <b>cómo se envía un uno, cómo se envía un cero, cómo se recibe un uno, cómo se recibe un cero</b>.<br>
<br>
Empezando por la parte de enviar. Según el datasheet, para sacar al transpondedor del modo <em>default read</em> éste debe percibir un corte del campo magnético, como una señal de <b>escape</b>. Lo llaman <em>First Field Stop</em>. Para estar seguros, el datasheet nos recomienda cortar durante 55 ciclos de 125kHz, o 440µs.<br>
<br>
Enviar un <b>uno</b> es sencillo: dejar el campo encendido 32 periodos. Es decir, la velocidad de transferencia del lector al transpondedor es RF/32. Para enviar un <b>cero</b> debemos dejar el campo encendido durante unos 20 periodos y cortarlo después hasta completar los 32 periodos.<br>
<br>
Tras recibir el comando, el EM4305 responderá. Así enviamos el comando de leer el registro 0:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/mod_field_noted.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="790" data-original-width="1174" src="img/mod_field_noted.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Comunicación con el EM4305 vista en el osciloscopio. Click para ampliar.</td>
</tr>
</tbody>
</table><br>
Abajo tenéis el campo de 125kHz tomado en la unión de <b>L</b> y <b>C2</b>. Arriba, la tensión presente en el comparador del PIC (patilla <b>6</b>). Venimos del modo <em>default read</em>. Enviamos el <em>First Field Stop (FFS)</em> y a continuación los bits del comando. Tras este sigue una pausa y finalmente la respuesta.<br>
<br>
La comunicación entre el lector y el chip tiene unos parámetros fijos. Pero en la respuesta el integrado utilizará los parámetros de velocidad y modulación configurados. De fábrica es modulación Biphase y velocidad RF/32.<br>
<br>
<br>
<br>
<b>El firmware</b><br>
<br>
No es trivial decidir qué se hace en el firmware y qué en el driver (software). Aquí sí, claro; porque es para nosotros. Pero en un producto comercial debe meditarse bien.<br>
<br>
Una <b>impresora</b>, por ejemplo. Le mandamos una imagen JPG, un documento DOCX o un PDF y debe saber interpretarlo, traducir la página a un mapa de bits, guardarlo en memoria, y controlar su electrónica para imprimir la imagen en papel. Para hacer todo eso debe tener un micro potente, RAM instalada según la resolución y un firmware muy elaborado. Esta impresora no necesita driver, es totalmente autónoma. Si le enchufamos un pendrive con documentos sería capaz de imprimirlos.<br>
<br>
Llega la hora de reducir costes. Somos fabricantes de impresoras. ¿Quitamos hardware de impresión? No, la bajada de calidad iba a ser muy evidente. ¿De dónde recortamos que se note poco? En el <b>firmware</b>. En vez de aceptar documentos en PDF y Word, aceptaremos sólo formato <a href="https://en.wikipedia.org/wiki/Printer_Command_Language">PCL</a>. Como el usuario va a querer seguir imprimiendo documentos, hacemos un <b>driver</b> que convierta a PCL. Como es todo software, no lo limitamos a los formatos corrientes, en su lugar añadimos muchos tipos de ficheros orígenes distintos... y lo vendemos como que nuestra impresora ahora soporta más formatos. Con otra ventaja: como PCL es un estándar, casi todos los sistemas tienen drivers compatibles.<br>
<br>
¿Por qué quedarnos ahí? ¿Por qué no hacer por <b>software</b> también el renderizado de la página? Que el driver envíe a la impresora directamente el mapa de bits en lugar de un lenguaje descriptivo intermedio. Así no hay que hacerlo por firmware, ya no necesitaríamos la RAM y el micro podría ser más básico y barato. Irá un poco más lenta... pero sería una impresora muy compacta, <b>económica</b> y consumirá menos electricidad, por tanto más ecológica. Eso vende pero tiene ciertos problemas, complica el driver y lo liga a un modelo concreto de impresora.<br>
<br>
Nuestro beneficio está en vender impresoras, no en hacer software. Como no nos es rentable mantener un driver tan complejo en varios sistemas operativos, nos centramos en <b>Windows</b>. ¿Qué pasa si alguien quiere usar esa impresora en un sistema operativo diferente? O, peor aún, ¿qué ocurrirá dentro de unos años cuando el driver sea <b>incompatible</b> con la última actualización?<br>
<br>
Lo que he descrito es una <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface#GDI_printers">Winprinter</a>. A finales de los 90 era frecuente encontrarte <a href="https://www.tldp.org/HOWTO/Modem-HOWTO-2.html#ss2.6">winmodems</a>, que no eran sino <a href="https://es.wikipedia.org/wiki/M%C3%B3dem_por_software">módems por software</a>. Hoy ocurre menos, pero cierto hardware -barato y popular- nunca funcionará bien en Linux y esta es la razón. Generalmente es más fácil configurar el hardware de gama media/alta. No porque en Linux sean unos elitistas, sino porque el firmware hace lo que debe hacer y su driver es más sencillo. El firmware actúa como pantalla abstrayendo al driver de la electrónica. Cuando el driver está muy ligado al hardware, se vuelve demasiado <b>específico</b>. Con un problema añadido: el fabricante nunca hará público ese nivel de detalle. De hecho, en ocasiones se necesita ingeniería inversa para entender cómo funciona.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/WinmodemAndRegularModem.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="1200" data-original-width="1600" src="img/WinmodemAndRegularModem.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
A la izquierda un Winmodem. El ahorro en componentes es a costa de un<br>
driver complejo y propietario. A la derecha un módem completo. Fuente: <a href="https://en.wikipedia.org/wiki/Softmodem" target="_blank">Wikipedia</a>
</td>
</tr>
</tbody>
</table><br>
Volviendo a nuestro proyecto, la idea es escribir un <em>firmware</em> lo más ligero posible y hacer por software todo lo demás.<br>
<br>
El lector/grabador sólo sabrá de <b>bits</b>. El PC le mandará un buffer y le dirá que envíe los 12 primeros bits y que lea una respuesta de 20. El micro los enviará, recuperará la respuesta y la mandará de vuelta. Sin saber qué ha enviado, ni si ha ido bien o ha ido mal. Aquí tan sólo entendemos de impulsos eléctricos, la interpretación se hace más arriba.<br>
<br>
Necesitaremos, al menos, funciones para:<br>
<ul>
<li>Enviar el FFS (First Field Stop), un 1 y un 0.</li>
<li>Recibir bits en modulación biphase.</li>
<li>Enviar el grupo de bits que se le mande desde el PC.</li>
<li>Leer un grupo de bits y mandarlo al PC.</li>
<li>Interpretar los comandos básicos del dispositivo.</li>
</ul><br>
Os lo dejo aquí en <a href="https://github.com/electronicayciencia/rfid-rw/tree/master/soft_pic">este enlace de GitHub</a>. También está el hex, por si os interesa probarlo y no tenéis compilador.<br>
<br>
La comunicación con el PC será vía <b>puerto serie</b>. Podría haber sido bluetooth o WiFi con un módulo apropiado, pero hoy usaremos un conversor USB a Serie. No obstante el 12F683 no tiene UART, es emulada. Así que simplificamos ¿es suficiente con comandos de una letra?<br>
<br>
Necesitaremos, al menos, comandos para:<br>
<ul>
<li>Enviar al PC la identificación del dispositivo. Debe incluir la versión del firmware instalada. Así el driver puede reconocerlo. Lo llamaremos <b>i</b>.</li>
<li>Enviar un grupo de bits (un comando) al transpondedor, leer la respuesta y devolverla al PC. Enviaremos un buffer y esperaremos otro buffer. Se llamará <b>c</b> y necesitaremos al menos indicar cuántos bits enviar y cuántos recibir.</li>
<li>Recibir un grupo de bits sin enviar nada. Servirá para leer el mensaje de nuestro chip en modo <em>default read</em>. Lo llamaremos <b>r</b>.</li>
<li>Encender/apagar el campo magnético, fijar la velocidad de lectura, modificar los umbrales del comparador, activar el modo debug, etc.</li>
</ul><br>
¿Y si el driver envía un comando no reconocido? Pensemos cómo reportar errores. Por ejemplo devolveremos el valor 0 si reconocemos el comando, lo ejecutamos y fue todo bien; 1 si reconocemos el comando, lo intentamos ejecutar pero algo falló; y 255 si ni siquiera conocemos ese comando.<br>
<br>
En cuanto a leer del chip, me gusta <b>Biphase</b> porque es independiente de la polaridad. Un paso largo es un paso largo ya sea positivo o negativo. También es fácil ver si empezaste a leer en un momento inoportuno porque puedes detectar ese error.<br>
<ul>
<li>Monitorizamos el nivel lógico de la línea. Y esperamos a que haya un cambio.</li>
<li>En este primer cambio empezamos a cronometrar hasta que cambie de nuevo.</li>
<li>Hay dos posibilidades que tarde un periodo o un semiperiodo. Si tarda un periodo entero, hemos recibido <b>un 1</b>. Ya está. Si tarda sólo un semiperiodo podría ser un 0. Nos anotamos "medio cero" y esperamos al siguiente cambio.</li>
<li>Si transcurre un semiperiodo, hemos recibido <b>un 0</b>. Pero si hubiera un periodo entero, entonces es un error de lectura.</li>
</ul>Con este dibujo se entenderá mejor:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/Biphase.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="328" data-original-width="484" src="img/Biphase.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Algoritmo de lectura Biphase en un microcontrolador.</td>
</tr>
</tbody>
</table>
<div class="separator" style="clear: both; text-align: center;"></div><br>
¿Y si la codificación real que envía el chip es <b>Manchester</b> y no Biphase? Sin problema: nosotros lo leemos en biphase igualmente y ya traduciremos el mensaje por software. Es más fácil eso que implementar dos decodificadores diferentes en el firmware.<br>
<br>
<br>
<br>
<b>Protocolo lógico</b><br>
<br>
Nuestro circuito envía unos y ceros a un chip y nos dice los unos y ceros que recibe del chip. Digamos que conocemos los <b>fonemas</b> del idioma. Pero debemos aprender <b>palabras</b> y frases si queremos comunicarnos.<br>
<br>
Para mandar un comando interrumpimos el <em>default read</em> con un First Field Stop, y seguidamente siempre ponemos un <b>cero</b>. Después vendrá el comando con sus parámetros.<br>
<br>
El EM4305 maneja tres <b>estructuras</b> de datos. Una para los <b>comandos</b>. Tiene 4 bits, 3 bits del comando empezando por menos significativo y un bit de paridad par.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/struct_cmd.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="44" data-original-width="412" src="img/struct_cmd.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Estructura para los comandos. Fuente: datasheet.</td>
</tr>
</tbody>
</table><br>
Los bits cc0, cc1 y cc2 dependerán del comando en cuestión:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/cmd_bits.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="197" data-original-width="434" src="img/cmd_bits.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Comandos del EM4305. Fuente: datasheet.</td>
</tr>
</tbody>
</table><br>
Una segunda estructura, de 7 bits, para las <b>direcciones</b> de los registros. Se utiliza por ejemplo en los comandos <em>read</em> o <em>write</em>. Como tenemos 16 registros necesitamos al menos 4 bits, primero el menos significativo. Luego vienen dos bits reservados para uso futuro (que siempre son cero), y al final un bit más de paridad par como antes.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/struct_addr.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="37" data-original-width="703" src="img/struct_addr.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Estructura para direcciones de memoria. Fuente: datasheet.</td>
</tr>
</tbody>
</table><br>
Y la tercera estructura, <b>datos</b>, es la más compleja. Son 45 bits y se usa para enviar el valor de un registro. Como el medio de comunicación no es muy fiable, han previsto un mecanismo de paridades parciales para asegurar la detección de errores. ¿Se podría haber hecho con un CRC? También. Los bits D0 a D31 son los bits de datos, los P son paridad por filas y los PC paridad por columnas. Ambas pares.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/struct_register.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="140" data-original-width="898" src="img/struct_register.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Estructura para datos. Fuente: datasheet.</td>
</tr>
</tbody>
</table><br>
Con estas palabras ahora formamos frases. Para leer el registro 0 enviaríamos el FFS y un 0, luego la estructura para el comando <em>read</em> (1001), y después la estructura de dirección 0 (0000000). Ese es el comando que habíamos enviado cuando vimos esta imagen:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/mod_field_noted.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="790" data-original-width="1174" src="img/mod_field_noted.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Envío del comando READ(0) y recepción de la respuesta.</td>
</tr>
</tbody>
</table><br>
La <b>respuesta</b> empezará siempre con uno de estos dos valores, a los que llama <em><b>preamble</b></em>. Si el preamble es 00001010 significa ejecución correcta. Si es 00000001 significa error. Ojo que el preamble lo ha podido mandar en Manchester o en Biphase, según cómo esté configurado.<br>
<br>
En este caso nos ha dado <b>00001010</b>, ok. A continuación nos envía el valor del registro usando para ello la estructura de datos.<br>
<br>
Para escribir en un registro, habríamos enviado la estructura del comando <b>write</b>, luego la estructura de dirección correspondiente, y después la estructura de datos con el valor que queramos tal como se describe en este esquema:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/cmd_table.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="361" data-original-width="1114" src="img/cmd_table.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Esquema de los comandos read y write. Fuente: datasheet.</td>
</tr>
</tbody>
</table><br>
<br>
<b>El software</b><br>
<br>
¿Recordáis cómo hemos ido simplificando el firmware y dejándole esa complejidad a nuestro yo del <b>futuro</b>?<br>
<br>
Pues como cabía esperar, nos ha quedado un software algo complejo, sólo voy a dar algunas pinceladas. Lo tenéis completo en GitHub: <a href="https://github.com/electronicayciencia/rfid-rw/blob/master/soft_pc/em4205.py">em4205.py</a>.<br>
<br>
Hay un conjunto de cosas básicas que hemos decidido hacer en el software:<br>
<ul>
<li>Interactuar con el firmware por el puerto serie haciendo uso de los comandos descritos anteriormente. <b>Codificar</b> los mensajes hacia y desde el grabador.</li>
<li><b>Identificar</b> el lector. Configurarlo a la velocidad necesaria.</li>
<li>Generar las <b>estructuras</b> de datos que hemos visto antes para los comandos, las direcciones y los datos. Esta última además de generarla, también debe saber decodificarla.</li>
<li>Componer los parámetros para cada <b>comando</b> y entender su respuesta.</li>
<li>Traducir a Manchester el mensaje que hemos leído en Biphase.</li>
</ul>Pero son cosas necesarias, aburridas. Sólo las hacemos para conseguir otras de mayor nivel, como <b>escribir</b> un mensaje, <b>configurar</b> los parámetros de modulación y velocidad o <b>leer</b> el mensaje en modo default read.<br>
<br>
Ahora bien, el software está tan acoplado al firmware que uno no hace nada sin el otro. Este mismo programa no nos serviría para controlar un grabador de otra marca, ni nuestro grabador podría funcionar sin este driver.<br>
<br>
La cuestión es si todo junto cumple el objetivo que nos habíamos puesto: por un lado aprender y por el otro...<br>
<br>
<br>
<b>Clonar un identificador</b><br>
<br>
El primer paso era <b>caracterizar</b> el mensaje. Así que empezamos leyendo en modo <em>default read</em> la tarjeta origen. Los parámetros por defecto de nuestro lector son Biphase y RF/32. Nos da eso:<br>
<br>
<pre><b>D:\&gt; py -i .\em4205.py</b><br>Electronicayciencia's EM4205/EM4305 writer. v1.02.<br>&gt;&gt;&gt; <b>read_stream()</b><br>497323236409786642155382248146820840100456150797347717440463976893159497012533375533055<br>&gt;&gt;&gt;<br></pre><br>
El mensaje en decimal no nos dice nada, así que lo formateamos en binario:<br>
<br>
<pre>&gt;&gt;&gt; <b>print("{0:0288b}".format(read_stream()))</b><br>1111111111111111111111111111111111111111111111111111111111111111<br>1111111111111111111111111111111111111111111111111111111111111111<br>1111111111111111111111111111111111111111111111111111111111111111<br>1111111111111111111111111111111111111111111111111111111111111111<br>11111111111111111111111111111111<br></pre><br>
No sé... muchos unos. La velocidad no es correcta. Probaremos con RF/64.<br>
<br>
<pre>&gt;&gt;&gt; <b>reader_datarate(64)</b><br>384<br>&gt;&gt;&gt; <b>print("{0:0288b}".format(read_stream()))</b><br>1000011110111001110101011010000100101011111011000000001000000010<br>1000011110111001110101011010000100101011111011000000001000000010<br>1000011110111001110101011010000100101011111011000000001000000010<br>1000011110111001110101011010000100101011111011000000001000000010<br>10000111101110011101010110100001<br>&gt;&gt;&gt;<br></pre><br>
Sí, mejor. Un patrón de unos y ceros que se repite en <b>bucle</b>. Pero los mensajes del EM4100 empezaban por nueve unos seguidos... y yo aquí no los veo. ¿Y si lo transformamos a Manchester? A propósito, no esperéis que el mensaje cuadre con el de arriba porque el lector empieza a leer a partir del <b>primer uno</b> que encuentra. Por tanto el buffer estará <b>rotado</b>.<br>
<br>
<pre>&gt;&gt;&gt; <b>print("{0:0288b}".format(biphase2manchester(288, read_stream())))</b><br>000000011000001010010111010011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>111111111000000001100000101001011101001100 <br>&gt;&gt;&gt;<br></pre><br>
¡Bien! Ya tenemos el mensaje.<br>
<br>
En el artículo <a href="../../../2019/12/leer-tarjetas-de-acceso-rfid-sin-arduino/articulo.html">Leer tarjetas de acceso RFID, sin Arduino</a> habíamos decodificado lo que significa ese mensaje, pero ahora sólo nos interesa reproducirlo tal cual.<br>
<br>
Hacemos una función para que nos devuelva el mensaje (64 bits junto a los nueve unos):<br>
<br>
<pre>&gt;&gt;&gt; <b>keyfob_64_manchester()</b><br>1111111110000000011000001010010111010011001001111100011001010110<br>&gt;&gt;&gt;<br></pre><br>
Tenemos que conseguir que el EM4305 nos devuelva este mismo mensaje en modo <em>default read</em>. Si probamos con un chip nuevo, los parámetros por defecto son RF/32, biphase y el mensaje es todo <b>ceros</b>:<br>
<br>
<pre>&gt;&gt;&gt; <b>read_stream()</b><br>Traceback (most recent call last):<br>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>  File ".\em4205.py", line 729, in read_stream<br>    raise TransponderError("Empty message")<br>__main__.TransponderError: Empty message<br>&gt;&gt;&gt;<br></pre><br>
Del modo <em>default read</em>, el datasheet dice lo siguiente:<br>
<br>
<em>In Default Read mode, the EM4205/4305 sends continuously its memory data starting from Word 5 and finishing with the last word according to the configuration word settings. After sending the last bit of the last word, readout continues without interruption with the first bit of Word 5.</em><br>
<br>
Numeramos los bits del mensaje en el mismo orden que los recibimos:<br>
<pre>0       0       1       2       3       4       4       5      6<br>0       8       6       4       2       0       8       6      3<br><b>1111111110000000011000001010010111010011001001111100011001010110</b><br></pre><br>
Debemos poner el primer bit que queremos que se envíe (el numero 0) en el bit menos significativo del registro 5. Este registro albergará los 32 primeros bits del mensaje, hasta el bit 31. El siguiente bit, el 32 hay que ponerlo en el bit menos significativo del registro 6 y así hasta el 63.<br>
<br>
Algo así:<br>
<br>
<pre>            3                              0<br>            1                              0<br>Registro 5  <b>10100101000001100000000111111111</b><br><br>            6                              3<br>            3                              2<br>Registro 6  <b>01101010011000111110010011001011</b><br></pre><br>
Lo escribimos así y probamos:<br>
<br>
<pre>&gt;&gt;&gt; <b>write(5, 0b10100101000001100000000111111111)</b><br>&gt;&gt;&gt; <b>write(6, 0b01101010011000111110010011001011)</b><br>&gt;&gt;&gt; <b>dump_all()</b><br>...<br>Word at position  5:  0xa50601ff (10100101000001100000000111111111)<br>Word at position  6:  0x6a63e4cb (01101010011000111110010011001011)<br>Word at position  7:  0x00000000 (00000000000000000000000000000000)<br>Word at position  8:  0x00000000 (00000000000000000000000000000000)<br>Word at position  9:  0x00000000 (00000000000000000000000000000000)<br>Word at position 10:  0x00000000 (00000000000000000000000000000000)<br>Word at position 11:  0x00000000 (00000000000000000000000000000000)<br>Word at position 12:  0x00000000 (00000000000000000000000000000000)<br>Word at position 13:  0x00000000 (00000000000000000000000000000000)<br>...<br></pre><br>
<br>
A continuación configuramos la modulación Manchester y la velocidad RF/64 igual que en el original:<br>
<br>
<pre>&gt;&gt;&gt; <b>config_datarate(64)</b><br>&gt;&gt;&gt; <b>config_encoder("manchester")</b><br>&gt;&gt;&gt; <b>print("{0:0288b}".format(biphase2manchester(288, read_stream())))</b><br>0010111010011001001111100011001010110<br>0000000000000000000000000000000000000000000000000000000000000000<br>1111111110000000011000001010010111010011001001111100011001010110<br>0000000000000000000000000000000000000000000000000000000000000000<br>11111111100000000110000010100101110100110010011111000110010<br></pre><br>
Aún nos falta una cosa: hay ceros entre medias. ¿Qué sucede? Por defecto se envían los registros 5, 6, 7 y 8. Y estos los habíamos dejado a <b>cero</b>. Aunque en el EM4305 se puede configurar dónde queremos que termine el mensaje y ponerlo en el 6, es más fácil replicar en los registros 7 y 8 el contenido de los anteriores.<br>
<br>
<pre>&gt;&gt;&gt; <b>write(7, 0b10100101000001100000000111111111)</b><br>&gt;&gt;&gt; <b>write(8, 0b01101010011000111110010011001011)</b><br>&gt;&gt;&gt; <b>dump_all()</b><br>...<br>Word at position  5:  0xa50601ff (10100101000001100000000111111111)<br>Word at position  6:  0x6a63e4cb (01101010011000111110010011001011)<br>Word at position  7:  0xa50601ff (10100101000001100000000111111111)<br>Word at position  8:  0x6a63e4cb (01101010011000111110010011001011)<br>Word at position  9:  0x00000000 (00000000000000000000000000000000)<br>Word at position 10:  0x00000000 (00000000000000000000000000000000)<br>Word at position 11:  0x00000000 (00000000000000000000000000000000)<br>Word at position 12:  0x00000000 (00000000000000000000000000000000)<br>Word at position 13:  0x00000000 (00000000000000000000000000000000)<br>...<br>&gt;&gt;&gt; <b>print("{0:0288b}".format(biphase2manchester(288, read_stream())))</b><br>0011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>1111111110000000011000001010010111010011001001111100011001010110<br>1111<br></pre><br>
¡Ahora sí! Veamos si la función que hemos definido antes devuelve el mismo mensaje para los dos chips.<br>
<br>
<pre><i>Con la original:</i><br>&gt;&gt;&gt; <b>keyfob_64_manchester()</b><br>1111111110000000011000001010010111010011001001111100011001010110<br><br><i>Con la copia:</i><br>&gt;&gt;&gt; <b>keyfob_64_manchester()</b><br>1111111110000000011000001010010111010011001001111100011001010110<br></pre><br>
Parecen idénticos. Pero... un momento, estamos haciendo todas las pruebas con un lector/grabador programado <b>por nosotros</b> mismos. ¿Hasta qué punto nos podemos fiar? No tengo un torno de verdad para probar, pero sí un lector comercial tipo RDM6300:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/rdm6300_reader.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="500" data-original-width="500" src="img/rdm6300_reader.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Lector comercial RFID 125kHz. Fuente: Aliexpress.</td>
</tr>
</tbody>
</table><br>
Con ayuda de un sencillo programa (que os dejo en GitHub: <a href="https://github.com/electronicayciencia/rfid-rw/blob/master/soft_pc/rdm6300.py">rdm6300.py</a>) comprobaremos si este lector también da la misma lectura para el original y la copia. Probaré a suplantar al <em>Sr. Jiminis</em> con mi llavero amarillo.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/fake_acces_control.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="149" data-original-width="924" src="img/fake_acces_control.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Control de acceso simulado. Se identifica al Sr. Jiminis con ambos dispositivos.</td>
</tr>
</tbody>
</table><br>
Suficiente. Confío que os haya resultado interesante esta revisión del mundo RFID de baja frecuencia, microcontroladores y software. Me despido no sin antes recomendar que, si aún estáis usando esta tecnología, <b>migréis</b> a otra más sofisticada.<br>
<br>
<br>
Os dejo el software, imágenes y otros archivos auxiliares en GitHub: <a href="https://github.com/electronicayciencia/rfid-rw">electronicayciencia/rfid-rw</a>.<br>
<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
<a href="img/meme-rfid.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="745" data-original-width="743" src="img/meme-rfid.png"></a>
</div><br>
<br>
</div>
<div class='post-labels'>
Etiquetas:
<ul>
<li>circuitos</li>
<li>microcontroladores</li>
<li>programacion</li>
</ul>
</div><!-- Above is post content -->
</div><!-- content-inner -->
</div><!-- content-outer -->
<script src="../../../resources/script_bottom.js">
</script>
</body>
</html>

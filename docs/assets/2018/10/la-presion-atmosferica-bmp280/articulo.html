<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
<link rel="stylesheet" href="../../../resources/style.css">
<script src="../../../resources/script.js">
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' type='text/javascript'>
MathJax.Hub.Config({
 extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
 jax: ["input/TeX", "output/HTML-CSS"],
 tex2jax: {
     inlineMath: [ ['$','$'], ['$$','$$'], ["\\(","\\)"] ],
     displayMath: [ ["\\[","\\]"] ],
 },
 "HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<title>La presión atmosférica, BMP280</title>
</head>
<body>
<div class="content-outer">
<div class="header">
<div class="title">
<h1>Electrónica y Ciencia</h1>
</div><!-- title -->
<div class="description">
<h2>Blog técnico sobre proyectos caseros de electrónica, informática y física.</h2>
</div><!-- description -->
</div><!-- header -->
<div class="content-inner">
<!-- Here the blog content -->
<h3 class='post-title entry-title'>La presión atmosférica, BMP280</h3>
<div class='post-date'>
Publicado el 07-10-2018.
</div>
<div class='post-body entry-content'>
Dedico esta entrada a la presión atmosférica. Ya sabéis, eso que cuando sube hace calor y cuando baja llueve.<br>
<br>
Hablaremos del BMP280, un sensor digital de presión y temperatura con comunicación I2C y SPI. Interpretar la lectura no es fácil, veremos los algoritmos que nos proporciona el fabricante y su API. Lo conectaremos a la Raspberry y registraremos la presión durante unos días. Para terminar estudiaremos las variaciones debidas a la llamada <em>marea barométrica</em> y los registros durante una breve tormenta.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/baro_goethe_peque.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="430" data-original-width="280" src="img/baro_goethe_peque.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Botella barométrica o barómetro de Goethe. EyC.</td>
</tr>
</tbody>
</table>
<div class="separator" style="clear: both; text-align: center;"></div>
<div class="separator" style="clear: both; text-align: center;"></div><br>
Hasta el siglo XVI, la ciencia que se enseñaba en las universidades, la ciencia de verdad, en la que creía todo el mundo sin discusión, era la física aristotélica. Entonces llegó Copérnico y nos mostró que, a veces, las verdades bien establecidas y enseñadas durante generaciones no son ciertas. Llegó Francis Bacon y nos enseñó que la ciencia y la dialéctica son cosas distintas; y que algo no es verdad tan sólo porque sea razonable. Galileo nos explicó cómo hacer experimentos y ayudarnos de los números para proceder. Newton recorrió ese camino para sintetizar la nueva ciencia de la época en su obra culmen -que todos conocéis-, enterrando para siempre la física aristotélica.<br>
<br>
Esta revolución ocurrió a lo largo del s.XVII, y cambió el modo de hacer ciencia a partir de entonces. Contribuyó a ello sin duda el descubrimiento de que el aire es material, que de hecho ofrece resistencia a los cuerpos que caen y, sobre todo de que <em>el aire <b>pesa</b></em>.<br>
<br>
Todo comenzó cuando alguien intentó bombear agua de un pozo de más de 10 metros de profundidad... <a href="https://en.wikipedia.org/wiki/Barometer#History">y vio que no se podía</a>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/BMP280.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="228" data-original-width="276" src="img/BMP280.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
Sensor barométrico BMP280. <a href="https://www.bosch-sensortec.com/bst/products/all_products/bmp280" target="_blank">Bosch</a>.
</td>
</tr>
</tbody>
</table><br>
<br>
<a name='more' id="more"></a><br>
<br>
<b>El sensor</b><br>
<br>
El BPM280 es un sensor fabricado por Bosch para medir presión y temperatura ambiental. Pertenece a la gama <a href="https://www.bosch-sensortec.com/bst/products/all_products/bmp280">Sensortec</a>. Hay otro sensor parecido, el BME280 (acabado en E, en lugar de en P). Mide presión, temperatura y también humedad. En eBay están casi al mismo precio. Pero si lo compráis sabed que algunos fabricantes envían <em>por error</em> el modelo P, que sólo mide presión y temperatura. <a href="https://goughlui.com/2018/08/05/note-bosch-sensortec-bmp280-vs-bme280-sensor-confusion/">BMP280 vs. BME280 sensor confusion</a>.<br>
<br>
El BMP280 puede comunicarse tanto por I2C como por SPI. Dependiendo de si el pin CSB está a nivel alto o bajo. Un fallo habitual es dejar el pin CSB al aire, o con una resistencia de pull-up muy débil. Algún transitorio podría llevar el pin a nivel bajo. Cuando eso sucede, queda inhabilitada la comunicación por I2C hasta que se retire la alimentación. En ocasiones, el chip parece bloquearse y dejar de responder sin previo aviso, esta podría ser la causa.<br>
<br>
Usar este dispositivo con la Raspberry es <a href="http://wiki.sunfounder.cc/index.php?title=BMP280_Pressure_Sensor_Module#BMP280_for_Raspberry_Pi">muy sencillo</a>: basta conectarlo a los pines I2C, habilitar i2c, descargar las librerías apropiadas de C o de Python y tirar con el ejemplo.<br>
<br>
¡Ya está! ¿Para qué complicarse? Fin del tutorial.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/digital-art-happiness.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="537" data-original-width="750" src="img/digital-art-happiness.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
We live in a happy world. <a href="https://www.pinterest.es/pin/544794886163949157/" target="_blank">Pinterest</a>.
</td>
</tr>
</tbody>
</table><br>
<br>
Ahora bien, si buscas el detalle tecnológico, si te preguntas qué pasa dentro de esas librerías... si encuentras el camino más interesante que el destino, sigue leyendo... y prepárate.<br>
<br>
En esta página (<a href="https://www.bosch-sensortec.com/bst/products/all_products/bmp280">https://www.bosch-sensortec.com/bst/products/all_products/bmp280</a>) tenemos toda la información del BMP280. En la sección de descargas está el datasheet, y también el "driver".<br>
<br>
Voy a empezar por conectar el integrado a los pines 10 y 11 (numeración de WiringPi). Dichos puertos no poseen I2C por hardware nativo. Utilizaré las librerías de emulación I2C software <em><a href="https://github.com/electronicayciencia/wPi_soft_i2c">wPi_soft_I2C</a></em>.<br>
<br>
Primeramente, debemos asegurarnos de que el chip está conectado y responde. Lo haremos escaneando el bus con la utilidad de línea de comandos <em>i2cli</em>:<br>
<br>
<pre>pi@raspberrypi:~/bmp280/soft_i2c$ ./i2cli 10 11<br>I2C Command Line Interface<br>I2C ready. SCL: 10, SDA: 11<br>Valid commands are:<br>...<br>   C: sCan<br>   q: quit<br><br>i2cli &gt; C<br> * Device found at 76h  (R: ed, W: ec)<br>i2cli &gt;<br></pre><br>
Sí, la dirección 76h es lo esperado. El chip funciona. Procedemos a leer o escribir algún registro. Por ejemplo el ID de dispositivo, localizado en la dirección D0h. En la entrada titulada <a href="../../../2017/02/el-bus-i2c-bajo-nivel/articulo.html">El bus I2C a bajo nivel</a> tenéis descrito el procedimiento para leer o escribir un byte manualmente.<br>
<br>
De forma resumida: se llama al chip con su dirección de escritura y se escribe la dirección donde está el registro a leer. A continuación llamamos al chip con su dirección de lectura, y leemos un byte.<br>
<br>
<pre>i2cli &gt; C<br> * Device found at 76h  (R: ed, W: ec)<br>i2cli &gt; s    ; start<br>i2cli*&gt; wec  ; dirección del chip para escritura<br>ec -&gt; ACK<br>i2cli*&gt; wd0  ; dirección del registro<br>d0 -&gt; ACK<br>i2cli*&gt; s    ; restart<br>i2cli*&gt; wed  ; dirección del chip para lectura<br>ed -&gt; ACK<br>i2cli*&gt; r    ; comando de lectura<br>r -&gt; 58<br></pre><br>
El integrado se identifica como 58h, propio del BMP280. Si fuera el BME280 habría devuelto 60h. Esta es la forma más fiable de identificar cuál es el modelo de nuestro sensor.<br>
<br>
La complejidad del BMP280 radica en su elevado número de registros, un total de 35:<br>
<ul>
<li>3 registros para la presión (20 bytes)</li>
<li>3 registros más para la temperatura (20 bytes)</li>
<li>5, para configuración y operaciones varias</li>
<li>y 24, 24 registros, contienen los datos de calibración interna</li>
</ul><br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/memory_map.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="552" data-original-width="1416" src="img/memory_map.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Mapa de memoria del BMP280. Datasheet.</td>
</tr>
</tbody>
</table><br>
¿Qué se hace con todos estos datos?<br>
<br>
Primero, se configuran las opciones del sensor fijando los valores apropiados en los registros de configuración. Luego se descarga uno los datos de calibración y se los guarda. Después, recuperamos los 6 registros con los valores de presión y temperatura.<br>
<br>
Y a partir de ahí, obtenemos la lectura real con un sencillo cálculo guiados por el ejemplo del datasheet:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/algoritmo.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="536" data-original-width="1108" src="img/algoritmo.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">La lectura real se obtiene mediante un sencillo cálculo.</td>
</tr>
</tbody>
</table><br>
El fabricante nos proporciona un driver ya listo con este algoritmo implementado de forma eficiente. Pero antes de usarlo, comprendámoslo.<br>
<br>
<br>
<b>El algoritmo</b><br>
<br>
Los barómetros, por lo general se encuentran influidos por la temperatura ambiente. Es muy fácil de ver en un tipo de barómetro llamado <b>barómetro de Goethe</b>; más conocido en eBay como <em>Glass Barometer Weather Forecast Rain Shine Bottle</em>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/baro_goethe.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="896" data-original-width="584" src="img/baro_goethe.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Botella barométrica. El extremo superior está abierto. EyC.</td>
</tr>
</tbody>
</table><br>
Primero llenamos la botella de líquido. El nivel en el brazo lateral, cuyo extremo superior está abierto, alcanza una determinada altura. La presión dentro de la esfera interior no puede variar. Así pues, cuando aumenta la presión exterior, entra por el extremo abierto y empuja el líquido hacia abajo. Y si la presión atmosférica desciende, es la presión dentro de la esfera la que empuja el líquido a subir.<br>
<br>
Es decir, que cuando la presión aumenta el nivel baja, y cuando la presión disminuye el nivel del líquido aumenta. Es una idea estupenda si uno no tiene en cuenta la temperatura.<br>
<br>
Porque cuando la <b>temperatura</b> aumenta, tanto el agua como el gas contenido en la esfera cerrada se expanden, ocupando más volumen. Por tanto la presión <em>en la esfera</em> aumenta y empuja el líquido hacia arriba. Exactamente igual que si la presión desciende.<br>
<br>
Líquido bajo: ha subido la presión o hace más <i>frío</i>.<br>
Líquido alto: ha bajado la presión o hace más <i>calor</i>.<br>
<br>
La lectura del barómetro siempre debe compensarse con la del termómetro. Por eso es común ver juntos barómetro y termómetro.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/termo_barometer.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="500" data-original-width="500" src="img/termo_barometer.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
Barómetro y termómetro juntos. <a href="https://www.amazon.com/Educational-Innovations-Eco-celli-Barometer/dp/B009P8ALI4" target="_blank">Amazon</a>.
</td>
</tr>
</tbody>
</table><br>
Con frecuencia, omiten la tabla de compensación en los barómetros de interiores, donde se supone que el rango de temperaturas está acotado. El BMP280 introduce la compensación de temperatura dentro del algoritmo de lectura.<br>
<br>
No he podido encontrar documentos de Bosch explicando el cálculo, por lo que intentaremos hacernos una idea del cálculo operando matemáticamente y reordenando los términos hasta llegar a alguna expresión reconocible.<br>
<br>
Según podemos ver, se compone de dos funciones, una para la temperatura y otra para la presión.<br>
<br>
Empezaremos por la temperatura. Miramos la función <a href="https://github.com/BoschSensortec/BMP280_driver/blob/d1936f9f04f851403f616574ad3493ffd00d16fb/bmp280.c#L505-L511"><em>bmp280_comp_temp_double</em></a> del API oficial en GitHub. Cito aquí las líneas más relevantes.<br>
<br>
<pre class="cpp" name="code">var1 = (((double) uncomp_temp) / 16384.0 - ((double) dev-&gt;calib_param.dig_t1) / 1024.0)<br>* ((double) dev-&gt;calib_param.dig_t2);<br>var2 = ((((double) uncomp_temp) / 131072.0 - ((double) dev-&gt;calib_param.dig_t1) / 8192.0)<br>* (((double) uncomp_temp) / 131072.0 - ((double) dev-&gt;calib_param.dig_t1) / 8192.0))<br>* ((double) dev-&gt;calib_param.dig_t3);<br>dev-&gt;calib_param.t_fine = (int32_t) (var1 + var2);<br>temperature = (var1 + var2) / 5120.0;<br></pre><br>
Lo primero en que me fijaría es en las variables de entrada y salida: <em>uncomp_temp</em> es la lectura en crudo. Además, tenemos como dato los parámetros de calibración <em>dig_t1</em>, <em>dig_t2</em> y <em>dig_t3</em>. Con esto calculamos la temperatura <em>temperature</em> como tal, más un parámetro adicional de calibración llamado <em>t_fine</em>. Es el que se usará después para compensar la lectura de presión.<br>
<br>
Lo segundo, me fijaría en las constantes: 1024, 8192, 16384, 131072... casi todo son potencias de 2, salvo el 5120 (pero casi: 512 por 10).<br>
<br>
Claramente recuerda a la <a href="https://es.wikipedia.org/wiki/Coma_fija">aritmética de coma fija</a>. Repasémosla brevemente. Supón que quiero sumar dos números no enteros: por ejemplo 2.3 y 6.5, el resultado es 8.8.<br>
<br>
Ahora en un microcontrolador. Podría usar aritmética de coma flotante directamente, por supuesto:<br>
<br>
<pre class="cpp" name="code">int main () {<br>    float a = 2.3;<br>    float b = 6.5;<br><br>    printf("Suma: %f\n", a + b);<br>}<br></pre><br>
Lo cual sería estupendo si nuestro procesador puede usar una <a href="https://es.wikipedia.org/wiki/Intel_8087">Unidad de Punto Flotante</a>, bien externa, o bien incluida en la arquitectura de la CPU. Si no tenemos, entonces el compilador incluirá todo el código necesario para emularlo las operaciones por software. Y eso, amigos, nos ocupará una buena cantidad de ROM y bastantes ciclos de reloj.<br>
<br>
Mira lo que pasa en un microcontrolador PIC de gama baja al sumar dos números en coma flotante:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/floating_point.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="430" data-original-width="1062" src="img/floating_point.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Suma de dos números de precisión sencilla en un PIC 12F, 162 instrucciones. EyC.</td>
</tr>
</tbody>
</table><br>
¡162 instrucciones! 162 instrucciones por cada suma. ¡Casi 32us para la operación aritmética más simple: sumar dos números!<br>
<br>
¿Qué tal si en vez de sumar 2.3 más 6.5, sumamos 23 más 65? Ahora la operación se convierte en suma de enteros, dando 88. Eso sí, debemos dividir el resultado entre 10 cuando vayamos a presentarlo al usuario.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/fixed_point.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="426" data-original-width="1046" src="img/fixed_point.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Suma de dos números enteros en un PIC 12F, 7 instrucciones. EyC.</td>
</tr>
</tbody>
</table><br>
Sólo 7 instrucciones. Varias de las cuales habrán sido para asignar a registros los valores de <b>a</b> y <b>b</b>, y otras tantas para operar con dos registros de 8 bits juntos como si fueran uno de 16.<br>
<br>
El caso ahora es dividir entre 10. ¿No estamos ante el mismo escenario de coma flotante? Sí, pero la división sólo la haremos <b>al final</b>, a la hora de mostrar el resultado al usuario por pantalla por ejemplo. Mientras, durante el cálculo -que seguro es más complejo que una suma- habremos usado todo el tiempo aritmética entera.<br>
<br>
El factor 10 se conoce con el nombre de <em>factor de escala</em>.<br>
<br>
En realidad no usamos potencias de 10 -fáciles para nosotros- sino potencias de 2 -fáciles para un micro-. Porque, igual que para nosotros multiplicar o dividir por potencias de 10 es correr la coma a la izquierda o a la derecha, en binario multiplicar o dividir por potencias de 2 es desplazar todos los bit a la izquierda o a la derecha.<br>
<br>
Sigamos con los números del ejemplo anterior. Queremos escalar 2.3 a una potencia de 2. He hecho una tabla para el cálculo. La he compartido y podéis verla <a href="https://docs.google.com/spreadsheets/d/1fQlrgfiAizZDGOhC3fAPFQ1Vk6SMFsVKXnL850K32F8/edit?usp=sharing">aquí</a>. Este sería el error cometido en función del factor de escala:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/fixed_point_table_2.3.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="485" data-original-width="693" src="img/fixed_point_table_2.3.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Escalado de un número decimal a una potencia de 2 con un tamaño de 8 bits. EyC.</td>
</tr>
</tbody>
</table><br>
Si el tamaño de entero del procesador fuera 8 bits, no podremos escalarlo más allá de 256 que es el valor máximo. Meteríamos en el registro el valor 147 y nuestro factor de escala sería 64. Lo cual nos daría un error de 3 milésimas.<br>
<br>
Todo hay que tenerlo en cuenta a la hora de operar. Por eso aparecen en el algoritmo tantos factores en forma de potencia de dos. A continuación voy a llevarme las constantes que multiplican o dividen y dejarlas en los parámetros de calibración.<br>
<br>
Seguimos con el ejemplo de la página 23 del datahseet. Dado el valor leído de la temperatura y los parámetros de calibración <b>t1</b>, <b>t2</b> y <b>t3</b>. Procedemos a reescalarlos y operar. El algoritmo ahora es más fácil de ver:<br>
<br>
<pre class="cpp" name="code">t = 519888;  % lectura<br><br>% Calibración (dato)<br>t1 = 27504;<br>t2 = 26435;<br>t3 = -1000;<br><br>% Escalado de parámetros<br>t  = t  / 2^14;<br>t1 = t1 / 2^10;<br>t2 = t2 / 2^9;<br>t3 = t3 / 2^15;<br><br>% Cálculo (algoritmo desnudo)<br>t    = t - t1;<br>temp = t * t2 + t^2 * t3;<br><br>% Resultado final<br>temp = temp / 10<br><br>% temp = 25.0825<br></pre><br>
El primer parámetro de calibración <b>t1</b> se utiliza para corregir la temperatura inicial. Y los dos siguientes <b>t2</b> y <b>t3</b>, entran en una corrección polinómica de segundo grado. A la hora de mostrar el resultado, se debe dividir entre 10.<br>
<br>
Para la presión, las operaciones son más enrevesadas. Entran a formar parte del cálculo 9 parámetros de calibración divididos en tres grupos, además del calculado anteriormente a partir de la temperatura. Nos llevamos de nuevo las constantes a los parámetros y operamos. Así vemos la forma del algoritmo:<br>
<br>
<pre class="cpp" name="code">p = % valor leído<br><br>a = 40 * (temp - 25);<br><br>dilatacion   = a^2 * p6 + a * p5 + p4<br>compensacion = (a^2 * p3 + a * p2 + 1) * p1<br><br>p = ( 2^20 - p - dilatacion ) * 6250 / compensacion<br>correccion = p^2 * p9 + p * p8 + p7<br><br>p = p + correccion<br></pre><br>
Lo primero, hemos creado una variable <b>a</b> donde entra la corrección en temperatura. La desviación fija de 25º nos recuerda a las <a href="https://en.wikipedia.org/wiki/Standard_conditions_for_temperature_and_pressure">condiciones estándar de presión y temperatura</a> según la IUPAC. No encuentro significado para el factor 40.<br>
<br>
En mi interpretación del algoritmo, yo diría que el calor influye sobre el BMP280 de dos maneras distintas. Por un lado <i>dilata</i> el material y aumenta la lectura, y por otro lado <em>ablanda la escala</em> haciendo que pequeños incrementos de presión se noten como si fueran mayores.<br>
<br>
El primer efecto lo corregimos con un parámetro llamado <b>dilatacion</b>. Este valor está modelado por un polinomio de segundo grado cuyos parámetros son los valores de calibración <em>p4</em>, <em>p5</em> y <em>p6</em>.<br>
<br>
El segundo efecto lo he llamado <b>compensacion</b> y viene modelado por otro polinomio también de segundo grado con los factores <em>p1</em>, <em>p2</em> y <em>p3</em>.<br>
<br>
La presión leída se resta del valor máximo (2 elevado a 20 porque el registro es de 20 bits) y se le resta a su vez el aumento por dilatación. El resultado se divide por el valor de compensación de escala obtenido anteriormente.<br>
<br>
Al igual que con la temperatura, para obtener el valor exacto de presión, este número lo introducimos en un polinomio de ajuste, llamado <b>correccion</b> dado por los parámetros <em>p7</em>, <em>p8</em> y <em>p9</em>. La presión final se corrige de acuerdo a este resultado.<br>
<br>
Si te has perdido durante la explicación, es lógico. Aquí está el fichero con un algoritmo equivalente al del fabricante: <a href="https://github.com/electronicayciencia/bmp280_sensor/blob/master/bmp280_alg/bmp280_alg.m">bmp280_alg.m</a><br>
<br>
<br>
¿Por qué el fabricante nos lo da <i>ofuscado</i>? La palabra clave aquí es <b>rendimiento</b>. Se aprecia el esfuerzo de los ingenieros de Bosch. Le han dado muchas vueltas para que un cálculo tan complejo pueda ejecutarse en un microcontrolador simple sin FPU con un rendimiento y pérdida de precisión aceptables. Es un trabajo nada sencillo, y seguro que les ha llevado muchas horas.<br>
<br>
En su API, el fabricante nos ofrece funciones para calcular la temperatura con coma fija de 32 bits y en coma flotante. Para la presión nos da la opción de usar coma fija con registros de 64 bits o coma flotante.<br>
<br>
He preparado una tabla con los tiempos en segundos con y sin optimizaciones del compilador, para 10 millones de iteraciones en una Raspberry Pi 3.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/tabla_rendimiento.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="188" data-original-width="543" src="img/tabla_rendimiento.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Rendimiento de las funciones en una Raspberry Pi 3.<br>
10M iteraciones. Tiempo en segundos. EyC.</td>
</tr>
</tbody>
</table><br>
En el cálculo de la <b>temperatura</b>, la aritmética de punto fijo supera a la de coma flotante. En cambio, si nos vamos al cálculo de la <b>presión</b>, es al revés, la aritmética de 64bits es más lenta que la coma flotante. ¿Por qué?<br>
<br>
La respuesta está tanto en la arquitectura ARM como en el sistema Operativo.<br>
<br>
Mientras la Raspberry Pi 3 tiene un core ARMv8, el sistema operativo Raspbian es una versión para 32 bit. Esto hace que el procesador trabaje <a href="https://www.raspberrypi.org/forums/viewtopic.php?t=140572">emulando la arquitectura ARMv7</a>, de 32bit. Resulta que la arquitectura ARM <b>sí tiene</b> unidad de punto flotante. Es decir, para trabajar con registro de 64 bits, el compilador debe unir dos de 32 y operarlos como un todo. Mientras las operaciones en coma flotante se ejecutan nativamente en la FPU, más rápida.<br>
<br>
A la vista del resultado, utilizaremos las funciones de doble precisión.<br>
<br>
<br>
<b>API en C, driver del fabricante</b><br>
<br>
Dada la complejidad de configuración y de lectura del BMP280, el fabricante nos ofrece un API con rutinas listas para usar. Está en GitHub: <a href="https://github.com/BoschSensortec/BMP280_driver">BMP280 sensor API</a>.<br>
<br>
Si bien tiene todo lo necesario para interactuar con el sensor, requiere programación por nuestra parte. No es una librería completa en el sentido de <em>compilar y listo</em>. Nos dicta la interfaz para una rutina que escribirá por el puerto I2C o SPI, pero no la implementa. Esto, que es común en otros lenguajes como Java, es menos frecuente verlo en C. Vamos a explicar cómo hacer funcionar el API con nuestra librería de I2C.<br>
<br>
Para empezar, el usuario tiene que proporcionar tres funciones:<br>
<ul>
<li>Una función que escriba un número de bytes utilizando el puerto I2C.</li>
<li>Una función que lea un número de bytes utilizando el puerto I2C.</li>
<li>Una función que espera un número de milisegundos.</li>
</ul><br>
Si os fijáis, estas son las funciones más ligadas al <b>hardware</b>. Mientras el cálculo y procesamiento son prácticamente C estándar y sirven para cualquier sistema, la forma de enviar un byte por I2C varía mucho entre un PIC y una Raspberry. Se hace así para no ligarse a un procesador concreto.<br>
<br>
La interfaz necesaria para las dos primeras funciones la encontramos en las <a href="https://github.com/BoschSensortec/BMP280_driver/blob/d1936f9f04f851403f616574ad3493ffd00d16fb/bmp280_defs.h#L284-L288">líneas 284 a 288</a> del fichero <a href="https://github.com/BoschSensortec/BMP280_driver/blob/master/bmp280_defs.h">bmp280_defs.h</a>.<br>
<br>
<pre class="cpp" name="code">/*! @name Function pointer type definitions */<br>typedef int8_t (*bmp280_com_fptr_t)(uint8_t dev_id, uint8_t reg_addr,<br>  uint8_t *data, uint16_t len);<br><br>typedef void (*bmp280_delay_fptr_t)(uint32_t period);<br></pre><br>
La primera línea define un puntero a una función que devuelve un entero de 8 bits, y recibe estos parámetros:<br>
<ul>
<li><b>dev_id:</b> Dirección I2C del dispositivo, es la dirección I2C donde está escuchando el chip.</li>
<li><b>reg_addr:</b> Dirección del primer registro para la operación de escritura o lectura.</li>
<li><b>data:</b> Puntero a un buffer con la secuencia de bytes a escribir o donde guardaremos los bytes leídos.</li>
<li><b>len:</b> Número de bytes por escribir o leer.</li>
</ul><br>
La segunda línea define un puntero a otra función que no devuelve nada (void), y recibe un sólo parámetro de tipo entero de 32 bit sin signo. Es el periodo de espera en milisegundos.<br>
<br>
Aunque el código puede ser largo se sigue fácilmente. Las podéis ver en <a href="https://github.com/electronicayciencia/bmp280_sensor/blob/c26c8c193b1d900d9ba119b6720d01ea7200306c/read_bmp280.c#L30-L57">read_bmp280.c líneas 30 a 57</a> y en <a href="https://github.com/electronicayciencia/bmp280_sensor/blob/c26c8c193b1d900d9ba119b6720d01ea7200306c/read_bmp280.c#L61-L94">líneas 61 a 94.</a><br>
<br>
Si en lugar de I2C por software prefieres usar I2C nativo o SPI, deberás programar tus propias funciones que hagan esto mismo. De igual modo, si estás usando otro hardware en lugar de Raspberry, tal como por ejemplo Arduino o PIC, estas funciones cambiarán un poco.<br>
<br>
No se indica el valor del entero de 8 bit que deben devolver. Del código deducimos que si todo va bien deben devolver la constante <em>BMP280_OK</em>, y en caso de problemas devolver la constante <em>BMP280_E_COMM_FAIL</em>. La API se encargará de tratar los errores convenientemente.<br>
<br>
Hasta aquí la parte más difícil. Ahora le pasamos al API un puntero a cada una de las tres funciones, con eso rellenamos los huecos y podemos empezar a usarla.<br>
<br>
Comprobaremos el correcto funcionamiento recuperando el ID de dispositivo. Ya lo obtuvimos antes manualmente y sabemos que es 0x58. Eso es precisamente lo que hacemos en <a href="https://github.com/electronicayciencia/bmp280_sensor/blob/master/test_bmp280_api.c">test_bmp280_api.c</a>.<br>
<br>
En dicho programa escribimos nuestras funciones de comunicación personalizadas. Inicializamos la librería WiringPi y la emulación I2C por software. Y de la línea 115 en adelante, configuramos el API y llamamos a la función de inicialización. Si todo ha ido bien, esta llamada rellenará el ID de dispositivo .<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/device_found58.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="71" data-original-width="609" src="img/device_found58.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">El ID del BMP280 es 58h. EyC.</td>
</tr>
</tbody>
</table><br>
A partir de aquí, se trata de experimentar con distintas configuraciones o filtros siguiendo la documentación.<br>
<br>
<br>
<b>Valores de la presión</b><br>
<br>
La primera lectura del BMP280 nos puede parecer un tanto extraña. Si hemos usado el API de cálculo en coma flotante, el resultado será algo como <b>94394.834489</b>. El valor ya está directamente en Pascales. La presión atmosférica se da en hectopascales (hPa) o milibares, que es lo mismo. Es simplemente dividir entre 100, redondeando 944 hPa.<br>
<br>
Si sabes algo del tema, te sonara que el valor estándar es 1013 mbar. ¿944 no parece demasiado bajo?<br>
<br>
Recuerda que el sensor nos muestra el valor absoluto. Y varía con la altura. El dato de 1013 hPa se toma como la presión media <b>a nivel del mar</b>, es decir a una altura de 0 m. Como estamos más altos, nuestra lectura es menor.<br>
<br>
Por ejemplo, 1000 hPa es una presión baja en una ubicación cercana al mar, pero alta para un terreno elevado. Sabiendo nuestra altura sobre el nivel del mar, podemos calcular aproximadamente la presión media esperable por la altura.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/pressure_altitude.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="593" data-original-width="819" src="img/pressure_altitude.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
Presión en función de la altura. <a href="https://www.mide.com/pages/air-pressure-at-altitude-calculator" target="_blank">Fuente</a>.
</td>
</tr>
</tbody>
</table><br>
Madrid está de media a <b>667</b> m sobre el nivel del mar, lo cual corresponde a unos 937 hPa. Luego el valor 944 que nos parecía muy bajo, es hecho 7 milibares <em>superior</em> a la presión media. Diríamos que, con referencia al nivel del mar estaríamos a 1020 mbar (los 1013 estandar más el exceso de 7 mbar).<br>
<br>
Como la presión varía con la altura de forma muy lineal, se puede usar un barómetro para determinar la altura a la que vuela un avión. Se llama <b>altímetro barométrico</b>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/Altimeter_C-14A_2992.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="768" data-original-width="768" src="img/Altimeter_C-14A_2992.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
Altímetro barométrico. <a href="https://aeroantique.com/" target="_blank">aeroantique.com</a>
</td>
</tr>
</tbody>
</table><br>
Pero la presión sube y baja según el día, ¿cómo afecta eso a los aviones? Pues en el caso más simple, cuando estás en tierra, ajustas el altímetro hasta que marca la altitud conocida del aeródromo. Y para las aeronaves en vuelo, los aeropuertos transmiten continuamente el dato de la presión atmosférica mediante los servicios <a href="https://en.wikipedia.org/wiki/VOLMET">VOLMET</a> y <a href="https://en.wikipedia.org/wiki/Automatic_terminal_information_service">ATIS</a>. Al aproximarte al aeropuerto escuchas el dato de la presión (QNH) y ajustas el altímetro de acuerdo a la existente en la zona en ese momento.<br>
<br>
En la foto del altímetro anterior, fíjate en el número <b>29.92</b>. Es el valor de ajuste. 29,92 pulgadas de mercurio. Pasando las pulgadas a milímetros, resulta 760 mm de mercurio (mmHg).<br>
<br>
El milímetro de mercurio fue la primera unidad usada para medir la presión atmosférica. 760mm fue la altura que alcanzó el mercurio en el <a href="https://www.juliantrubin.com/bigten/torricellibarometer.html">experimento de Torricelli</a>. Si en vez de mercurio usáramos agua, 13.6 veces menos densa, la altura llegaría a los 10.34m... ni un centímetro más. Y por eso es físicamente imposible sorber agua de un pozo de más de 10.34m de profundidad.<br>
<br>
<br>
<b>Variaciones de la presión</b><br>
<br>
Volvemos a nuestro programa de registro <a href="https://github.com/electronicayciencia/bmp280_sensor/blob/master/read_bmp280.c">read_bmp280.c</a>. Esta es la evolución de la presión, tomada a intervalos de 1 segundo, durante los últimos días.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_mes.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="517" data-original-width="1080" src="img/presion_mes.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Registro de la presión atmosférica local. Click para ampliar. EyC.</td>
</tr>
</tbody>
</table><br>
En el gráfico, el tiempo está expresado como medida relativa, no absoluta. El día 1 no significa el primer día de mes, sino el primer día de registro. La presión también se expresa como variación sobre la media. Como pasa con muchas variables, el dato absoluto apenas significa nada, son sus variaciones lo que importa.<br>
<br>
Observemos la evolución a lo largo de cualquier día. Por ejemplo, el periodo entre los días 12 y 15.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_intradias.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="437" data-original-width="1080" src="img/presion_intradias.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Registro de la presión. Detalle. EyC.</td>
</tr>
</tbody>
</table><br>
Hay un máximo justo antes del medio día, y un mínimo a continuación. Pero fíjate en el gráfico completo, el de todos los días. Como a la mitad del día la presión desciende. Durante la mañana o la noche puede subir más, menos o estar estable, pero a mitad del día hay un descenso. Este patrón se repite todos los días y tiene nombre: se llama <a href="https://www.tiempo.com/ram/398982/la-marea-atmosferica-barometrica/"><b>marea barométrica</b></a>.<br>
<br>
Para evitar este inconveniente, la presión debe medirse siempre a la misma hora del día. Aunque nosotros usaremos un método algo más sofisticado.<br>
<br>
Sus causas no están del todo claras. Podría deberse al calentamiento de las capas altas de la atmósfera por acción del sol. O a la atracción diferencial del Sol y la Luna, como las mareas oceánicas. Algunos estudios relacionan valores de la presión anormalmente altos o bajos con la posición relativa de la luna.<br>
<br>
Para corroborar el efecto, utilizamos la <a href="../../../2011/08/la-transformada-de-fourier-no-es-magia/articulo.html">Transformada de Fourier</a>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_freqs_sin_filtrar.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="517" data-original-width="1080" src="img/presion_freqs_sin_filtrar.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Descomposición en el espacio de frecuencias. EyC.</td>
</tr>
</tbody>
</table><br>
En este blog trabajamos a menudo con ondas de radio de megahercios. También con ondas sonoras de kilohercios y alguna otra vez con vibraciones de unos pocos hercios. Las ondas de este artículo son muy lentas; con periodos de horas o de días enteros. Usaremos frecuencias de milihercios, o incluso <b>microhercios</b>. Esta breve tabla te ayudara:<br>
<br>
<pre>Periodo    Frecuencia<br>  48h   -&gt;   5.8 uHz<br>  24h   -&gt;  11.6 uHz<br>  12h   -&gt;  23.1 uHz<br>   8h   -&gt;  34.7 uHz<br>   6h   -&gt;  46.3 uHz<br>   1h   -&gt; 277.8 uHz<br><br> 1min   -&gt;  16.7 mHz<br>   1s   -&gt;   1.0  Hz<br></pre><br>
Tenemos dos picos en el espectro de frecuencias anterior. Un pico alrededor de 11.6uHz que se corresponde con 24 horas. Es el ciclo diario de la marea. Dicen que en el ecuador este ciclo es mucho más fuerte y muy preciso en el tiempo.<br>
<br>
Seguidamente otro pico en torno a 23 o 23.5uHz (12h). Es el semidiario y no está tan definido como el diario. No he observado picos en 8 o 6 horas.<br>
<br>
Podemos eliminar el efecto de marea para observar mejor la evolución diaria. Construiremos un filtro de ventana que anule estos dos picos en el espacio de la frecuencia. Después reconstruiremos la FFT y haremos la inversa.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_freqs_filtrardas.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="517" data-original-width="1080" src="img/presion_freqs_filtrardas.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Descomposición en frecuencias de la presión atmosférica, filtrada. EyC.</td>
</tr>
</tbody>
</table><br>
He usado una ventana gaussiana para anular los dos picos. Me gusta porque al transformar se transforma en otra gaussiana. Es sencilla de manejar. Vosotros podéis usar otra ventana diferente. Puede ser tentador llegar y poner a cero sin más los dos picos. Eso sería usar una ventana cuadrada, y las esquinas luego meten mucho ruido en la FFT.<br>
<br>
Una vez hecha la transformada inversa tenemos la evolución sin las variaciones debidas al efecto marea. He dejado en gris de fondo la onda original para poderla comparar.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_mes_filtrada.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="517" data-original-width="1080" src="img/presion_mes_filtrada.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Evolución de la presión atmosférica tras filtrar los efectos de marea. EyC.</td>
</tr>
</tbody>
</table><br>
No voy a interpretar el gráfico. Os diré, eso sí, que suele coincidir presión alta con cielo despejado y presión baja con nubes. Lo que no implica necesariamente frío, calor o lluvia.<br>
<br>
En otoño el cielo despejado significa días cálidos y noches frías. Si llueve o no dependerá de la temperatura y humedad de las masas de aire cercanas, que pasarán por donde estamos o no según la fuerza y dirección de viento. Por supuesto influirá también la latitud, la altitud, la estación del año, el tipo de clima, las condiciones de inversión térmica o isla de calor en las ciudades, los microclimas y otros muchos factores.<br>
<br>
<i>Predecir el tiempo va más allá de mirar el barómetro.</i><br>
<br>
<br>
<b>Viento y tormenta</b><br>
<br>
Como hemos visto, las bajas frecuencias (menores a 11uHz) dominan la evolución de la presión atmosférica. Para confirmarlo dibujaremos un espectrograma, como si la presión fuera un sonido de muy baja frecuencia.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_espectrograma.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="517" data-original-width="1080" src="img/presion_espectrograma.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Espectrograma de la presión atmosférica. EyC.</td>
</tr>
</tbody>
</table><br>
Nos llaman la atención varias franjas vacías en los días 3, 4 y 16; esos días hubo una pérdida de datos. En el gráfico de evolución anterior están interpoladas linealmente.<br>
<br>
El otro punto interesante está en las noches de los días 5 y 7. Hay una inusual presencia de frecuencias altas. La presión local sufre cambios abruptos y rápidos. Esto significa ráfagas de viento fuerte. También se aprecian ligeramente en otras noches, pero estos dos días son especialmente fuertes.<br>
<br>
¿A qué se deben? Fueron dos <b>tormentas</b>. Filtrando sólo esas altas frecuencias, vemos los cambios de presión propios durante el transcurso de una tormenta.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/presion_tormenta2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="517" data-original-width="1080" src="img/presion_tormenta2.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Variación de alta frecuencia en la presión atmosférica<br>
recogida durante una tormenta. EyC.</td>
</tr>
</tbody>
</table><br>
¿No recuerda a un terremoto? Y esta es una suave tormenta de septiembre, con una una intensidad pico a pico de apenas 0.7hPa... ¿Os imagináis una tormenta fuerte en altamar?<br>
<br>
<br>
Espero que os haya gustado este viaje por la electrónica digital, la aritmética, la programación y el procesado digital de señales. Los programas utilizados los tenéis en ente repositorio de GitHub: <a href="https://github.com/electronicayciencia/bmp280_sensor">bmp280_sensor</a>.<br>
<br>
<br>
</div>
<div class='post-labels'>
Etiquetas:
<ul>
<li>datalog</li>
<li>microcontroladores</li>
<li>raspberrypi</li>
</ul>
</div><!-- Above is post content -->
</div><!-- content-inner -->
</div><!-- content-outer -->
<script src="../../../resources/script_bottom.js">
</script>
</body>
</html>

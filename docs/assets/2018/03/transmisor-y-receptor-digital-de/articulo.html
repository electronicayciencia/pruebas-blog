<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
<link rel="stylesheet" href="../../../resources/style.css">
<script src="../../../resources/script.js">
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' type='text/javascript'>
MathJax.Hub.Config({
 extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
 jax: ["input/TeX", "output/HTML-CSS"],
 tex2jax: {
     inlineMath: [ ['$','$'], ['$$','$$'], ["\\(","\\)"] ],
     displayMath: [ ["\\[","\\]"] ],
 },
 "HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<title>Transmisor y receptor digital de ultrasonidos</title>
</head>
<body>
<div class="content-outer">
<div class="header">
<div class="title">
<h1>Electrónica y Ciencia</h1>
</div><!-- title -->
<div class="description">
<h2>Blog técnico sobre proyectos caseros de electrónica, informática y física.</h2>
</div><!-- description -->
</div><!-- header -->
<div class="content-inner">
<!-- Here the blog content -->
<h3 class='post-title entry-title'>Transmisor y receptor digital de ultrasonidos</h3>
<div class='post-date'>
Publicado el 30-03-2018.
</div>
<div class='post-body entry-content'>
Se puede transmitir información por cable, por infrarrojos, por teléfono, modulando un tono acústico, por ondas de radio... Hoy os voy a describir un sistema de comunicación digital por <b>ultrasonidos</b>. Algunos pensaréis que es un circuito vulgar y falto de originalidad. Pero os gustan los esquemas con operacionales, lo sé, lo veo en las estadísticas del blog. Os animo a leerlo.<br>
<br>
En este artículo describiremos primero analógicamente cómo funcionan transmisor y receptor. Después, ya en el terreno digital, programaremos el firmware del transmisor. En cuanto al receptor, haremos primero un software dedicado y para terminar nos meteremos en el sistema operativo con unas explicaciones un tanto más avanzadas.<br>
<br>
Utilizaremos transductores ultrasónicos a 40kHz como los que podéis encontrar en estos módulos para medir distancias. No he encontrado la referencia exacta, pero a la vista se parecen mucho a los que vienen en el datasheet del modelo <a href="http://www.farnell.com/datasheets/1686089.pdf">400ST160</a>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/mod_ultrasonido.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="342" data-original-width="530" src="img/mod_ultrasonido.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Medidor de distancia por ultrasonidos. Circuito de partida.</td>
</tr>
</tbody>
</table><br>
<br>
<a name='more' id="more"></a><br>
<br>
<b>El transmisor</b><br>
<br>
A la hora de proyectar un circuito para un propósito, considerad que <b>no existe</b> algo así como <em>el mejor</em>. Hay cientos de circuitos que sirven igualmente. A veces el mejor es el que emplea menos componentes. Otras el más económico, aunque más complicado. Podría ser el más duradero, el que obtiene mayor rendimiento a costa de reducir su vida útil, el que menos consume o más amplio rango de alimentación soporta.<br>
<br>
Un buen circuito es el que <b>funciona</b> y sirve a nuestros propósitos. Después siempre se puede mejorar. En general, para un aficionado, es aquel que usa los componentes más comunes y por tanto minimiza la compra.<br>
<br>
En este artículo quiero centrarme en el receptor, y por esa razón el esquema del transmisor debía ser muy sencillo. Decidí utilizar un microcontrolador PIC 12F386. Este tendrá ya preprogramado el mensaje, y generará la portadora de 40kHz necesaria para activar el altavoz. Utilizaremos modulación ASK (o más concretamente OOK) por ser la más sencilla.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/sch_transmisor.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="896" data-original-width="998" src="img/sch_transmisor.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Esquema eléctrico del transmisor. EyC.</td>
</tr>
</tbody>
</table><br>
El transductor podría requerir más corriente de la que puede suministrar el PIC, para no arriesgarlo lo excitamos mediante <b>Q1</b> y no directamente, así puedo darle la corriente necesaria sin preocuparme de si será muy alta para el PIC. Otras posibilidades habrían sido una salida push-pull como la que vimos en <a href="../../../2013/07/etiquetas-antihurto-magneto-acusticas/articulo.html">Cómo funcionan las etiquetas acustomagnéticas</a> o un buffer usando inversores.<br>
<br>
A propósito, cuando queráis excitar un led, un relé o cualquier cosa con un transistor NPN en modo conmutación, siempre emisor a tierra y carga al colector. Nunca al revés.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/buffer_emitter_to_ground.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="418" data-original-width="783" src="img/buffer_emitter_to_ground.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Conexión de una carga a un transistor NPN. EyC.</td>
</tr>
</tbody>
</table><br>
Un transistor NPN está diseñado para trabajar con tensión de base positiva respecto al emisor. Si colocáramos la carga entre emisor y masa, el emisor ya no estaría a 0V porque la carga tendrá una caída de tensión. Haciendo más positivo el emisor del NPN empeoramos su rendimiento.<br>
<br>
Los transductores piezoeléctricos se mueven cuando sienten una diferencia de potencial entre sus patillas. Pero a la vez son muy malos conductores. Si sólo interponemos el piezo entre colector y positivo tendremos un circuito abierto. Si el colector de Q1 no está polarizado no hay paso de corriente, y por tanto tampoco diferencia de potencial entre las patillas del transductor. <b>R2</b> está para cerrar el circuito. Con un altavoz magnético <b>R2</b> sería necesaria porque el circuito se cierra a través de la bobina.<br>
<br>
<b>C1</b> es el condensador de desacoplo. Cuando el altavoz empiece a emitir demandará más corriente, eso lo sabemos. Debido a la resistencia del cable de alimentación -sobre todo si es este largo- o de la batería -si esta es débil-, tal incremento de la demanda hará caer la tensión disponible en todo el circuito, también en el integrado. Tener <b>C1</b> es como tener una fuente de alimentación en miniatura pegada al micro para relajar las fluctuaciones.<br>
<br>
En cuanto al cuarzo, si bien el 12F386 tiene un generador de reloj interno hasta 8MHz, yo necesitaba más velocidad para otro proyecto y por ese motivo tuve que usar un cristal de cuarzo externo junto a los condensadores <b>C2</b> y <b>C3</b>.<br>
<br>
Veamos los valores. Si bien matemáticamente se puede calcular el valor óptimo de un componente, en la práctica eso solo sirve como orientación pues raramente usamos el valor exacto.<br>
<br>
Para calcular <b>R2</b> nos apoyaremos en la capacidad del transductor emisor indicada por su <a href="https://www.robot-electronics.co.uk/files/t400s16.pdf">datasheet</a>: 2400pF, pero ni siquiera estamos seguros de que ese datasheet corresponda a nuestro modelo. Cuando <b>Q1</b> corte, el transductor se descargará a través de <b>R2</b>. Dado que la oscilación será a 40kHz (25us de periodo), su valor debe ser tal que permita al altavoz descargarse completamente en este tiempo. Si hacéis la cuenta, una resistencia de 3k3 permitiría a un condensador de 2400pF descargarse un 99% en 24us. Se puede usar, por tanto, cualquier valor inferior a 3k3. Se suele usar 1k. Yo he puesto 220ohm porque en las pruebas daba mejor resultado, pero está por debajo de lo recomendado.<br>
<br>
<b>Q1</b> es de tipo NPN y debe soportar la corriente de colector. Con el valor anterior de R2 asciende a tan sólo 21mA. Usad el más barato que tengáis a mano. El 2N3904, por ejemplo, es muy práctico. Soporta hasta 200mA de corriente de colector y podéis encontrarlos por 1USD las 100 unidades.<br>
<br>
<b>R1</b>: Su valor debe ser tan bajo como para saturar <b>Q1</b> pero lo suficientemente alto como para no exceder la corriente máxima que puede proporcionar una patilla del 12F386: 25mA. La ganancia en corriente mínima garantizada de un 2N3904 es 30 (60 para el rango en que nos movemos y suele ser más de 100 en la práctica). Lo cual nos da para <b>R1</b> un valor comprendido entre los 172 y 5912 ohm. Por ejemplo 4k7 (con una ganancia de 100, 10k habría servido igualmente).<br>
<br>
<b>C1</b> suele ser de 0.1uF o incluso de 47nF. No es crítico para este circuito, nos vale prácticamente cualquier cosa por encima: 0.1uF, 1, 3.3, 10 y hasta 47 o 100uF.<br>
<br>
La máxima frecuencia de reloj para el 12F683 es 20MHz. Este será el valor de <b>XTAL1</b>. <b>C2</b> y <b>C3</b> deben tener un valor igual al doble de la capacidad del cristal, pero ese dato pocas veces lo conocemos. Lo típico es usar entre 18 y 33pF. Si nos equivocamos la frecuencia del oscilador será un poco mayor o menor de lo previsto. Lo cual dentro de unos márgenes no es importante en este circuito.<br>
<br>
Nuestro transmisor montado sobre una protoboard. Se aprecia el zócalo para el PIC, y el conector ICSP que usaremos para programarlo y para alimentar el circuito. Los cables de la derecha van al altavoz.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/pcb_transmisor.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="616" data-original-width="952" src="img/pcb_transmisor.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Transmisor montado sobre una placa perforada. EyC.</td>
</tr>
</tbody>
</table><br>
Más abajo hablaremos del firmware.<br>
<br>
<br>
<b>Ideas para el receptor</b><br>
<br>
Una vez construido (y programado) el transmisor, tomamos el osciloscopio para ver cómo se recibirían esos pulsos en el transductor receptor y qué nivel tienen en función de la distancia.<br>
<br>
En amarillo los pulsos transmitidos a 2000 <em>baudios</em>, aproximadamente 0.5ms de duración. Sus bordes están bien delimitados. En verde los pulsos recibidos: los bordes son difusos, llegándose a perder la distinción de dónde acaba un pulso y comienza el siguiente.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/resonancia_indeseada.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="779" data-original-width="1239" src="img/resonancia_indeseada.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Resonancia indeseada. Impide la transmisión a mayor velocidad. EyC.</td>
</tr>
</tbody>
</table><br>
¿Por qué ocurre esto? Porque transmisor y receptor son cavidades resonantes de Helmholtz con un factor de calidad muy elevado. Es decir, están ajustados para transmitir y recibir eficazmente una frecuencia de 40kHz, y sólo de 40kHz con un margen muy estrecho.<br>
<br>
Eso tiene cosas buenas y cosas malas. Lo bueno es no captar prácticamente ningún ruido de ambiente, lo cual nos va a ahorrar filtrar la señal recibida. Pero lo malo es que el ancho del canal es muy limitado, tan limitado que sólo cabe esa frecuencia. Como consecuencia, la oscilación no comienza inmediatamente ni tampoco se extingue tras cesar la excitación.<br>
<br>
Los pulsos se solapan con los siguientes. Aún se está extinguiendo la resonancia cuando ya ha comenzado el siguiente pulso. Eso se llama <a href="https://es.wikipedia.org/wiki/Interferencia_entre_s%C3%ADmbolos">interferencia entre símbolos (ISI)</a> y es propio de los canales con ancho de banda muy estrecho. Una cavidad resonante es, si me lo permitís, un caso extremo de ancho de canal limitado.<br>
<br>
Esperar a que la señal del símbolo previo se debilite lo suficiente significa bajar hasta una velocidad de transmisión más lenta, por ejemplo 1000 baudios.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/resonancia_indeseada_1kHz.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="777" data-original-width="1247" src="img/resonancia_indeseada_1kHz.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">La máxima velocidad de transmisión no va mucho más allá de 1000 baudios. EyC.</td>
</tr>
</tbody>
</table><br>
Ahora se distingue mejor. Con todo, cuando diseñemos el circuito hemos de tener en cuenta el arranque suave y la terminación exponencial de los pulsos.<br>
<br>
A propósito, ¿sabéis otra causa de la interferencia entre símbolos? Caminos múltiples (<b>multipath</b>). La onda se propaga en distintas direcciones y rebota en varios obstáculos antes de llegar al receptor. Por tanto se solapan señales de distintas amplitudes y fases. Con ultrasonidos se aprecia muy bien sin más que orientar el transmisor hacia una pared cualquiera de la habitación.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/multipath.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="734" data-original-width="1249" src="img/multipath.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Los caminos múltiples son otra causa de interferencia. EyC.</td>
</tr>
</tbody>
</table><br>
En cuanto al nivel captado, la señal recibida a un metro aproximadamente tiene una amplitud de unos 20mV. Varía mucho en función de la alineación. Pero ojo, cuando micrófono y altavoz están pegados mutuamente, la amplitud supera los 10V, luego será imprescindible un potenciómetro de volumen a la entrada.<br>
<br>
Antes de construir el receptor haremos algunas simulaciones. Para dotar a la simulación de cierto realismo primero crearemos una señal similar a la señal recibida anteriormente.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/mic_resonante.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="493" data-original-width="1314" src="img/mic_resonante.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Simulación de la señal recibida. EyC.</td>
</tr>
</tbody>
</table><br>
Se trata de un generador a 40kHz <b>V2</b> interrumpido periódicamente por el interruptor <b>S1</b> el cual se activa y desactiva a intervalos de 0.5ms. <b>C3</b> y <b>L1</b> forman un resonador para crear la forma de onda que veis a la derecha.<br>
<br>
<br>
El receptor que diseñemos será, en esencia, un circuito capaz de llevar su salida a nivel alto en presencia de la portadora de 40kHz, y dejarla a nivel bajo cuando esté ausente.<br>
<br>
Por supuesto hay infinidad de circuitos así. Dependiendo de los conocimientos, materiales disponibles, experiencias previas e inspiración se nos podría ocurrir algo como esto:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/sch_alternativa2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="468" data-original-width="1065" src="img/sch_alternativa2.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Una -mala- idea para el circuito receptor. EyC.</td>
</tr>
</tbody>
</table><br>
Una etapa amplificadora formada por el operacional <b>U1</b> en configuración no inversora, y las resistencias <b>R1</b> y <b>R2</b>. La amplificación teórica de esta etapa es de 301. Más que suficiente para amplificar la señal de entrada hasta los 0.7V necesarios para activar el diodo <b>D1</b> y cargar <b>C2</b>.<br>
<br>
<b>D1</b>, <b>C2</b> y <b>R3</b> forman un rectificador de media onda. Cuando haya señal, <b>C2</b> se cargará a través del diodo. Y cuando la tensión en el condensador sea suficiente como para excitar <b>Q1</b> este empezará a conducir llevando a masa la base de <b>Q2</b>, positiva hasta el momento. <b>Q2</b> irá a corte, dejará de conducir y en la salida se manifestará la tensión de alimentación positiva a través de <b>R8</b>.<br>
<br>
Cuando la señal de entrada cese, <b>C2</b> se descargará a través de <b>R3</b>. La base de <b>Q1</b> no recibirá su tensión de polarización, este dejará de conducir y por tanto <b>Q2</b> lo hará, llevando a masa la salida en ausencia de señal, tal como habíamos previsto.<br>
<br>
Resultado de la simulación:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/alternativa2_output.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="516" data-original-width="728" src="img/alternativa2_output.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Forma de onda de entrada (x100) y de salida en el receptor anterior. EyC.</td>
</tr>
</tbody>
</table><br>
Si bien funciona en la simulación con <b>LTSpiceIV</b> (muy fiable por otra parte), se pueden mejorar algunos aspectos.<br>
<br>
Para empezar, el LM324 (y su primo hermano dual el <b>LM358</b>) son operacionales muy simples, viejos -diseñados en 1972-, ruidosos, pero sobre todo <b>lentos</b>. Tienen una cosa buena, eso sí, valen a un dólar los 20. Hoy hay operacionales mucho mejores. Pero no utilizamos un operacional de 2 dólares si podemos hacer lo mismo con uno de 5 centavos. No es una cuestión de ser más o menos tacaño, es que por ese precio vale la pena tener siempre un puñado a mano para circuitos y pruebas varias. Un componente mediocre a mano siempre es preferible al componente óptimo que no tenemos.<br>
<br>
El ancho de banda a ganancia unitaria del LM358 es 1MHz (más baja aún, 0.7MHz según el modelo). Debe entenderse como el producto frecuencia por ganancia. O sea que podría pasar una señal de 1MHz sin amplificar, 100kHz amplificada por 10, 50kHz amplificada 20 veces... o 40kHz amplificada por 25.<br>
<br>
Posiblemente sea un poco más en la práctica dependiendo del chip, pero nada de una amplificación por 301 en una sola etapa por mucha resistencia de realimentación que pongamos.<br>
<br>
Otro posible problema es el siguiente. Para activar la base de <b>Q1</b>, la tensión en el condensador, junto a la proporcionada por las resistencias <b>R5</b> y <b>R6</b> debe superar los 0.6V. El valor de los componentes es difícil de ajustar y tienen muy baja tolerancia a las variaciones.<br>
<br>
Es un circuito muy sensible a los cambios en el nivel de entrada. Una señal más fuerte se manifestará con mayor intensidad y cargará el condensador antes que otra más débil. Asimismo, el comparador carece de histéresis y eso podría causar varios cambios seguidos en la salida antes de establecerse en un nivel alto.<br>
<br>
¿Las opciones? Os dije que había muchísimas. Podría desdoblar la etapa amplificadora usando dos LM358 en cascada. O quizá poner un preamplificador con un transistor y guardar ese segundo operacional para usarlo a modo de comparador con histéresis al final. En lugar de un rectificador, podría usar un integrador activo con un operacional. O, tal vez tomando otra ruta distinta, el esquema se simplificaría enormemente si usara un integrado tipo PLL como el <a href="http://www.ti.com/lit/ds/symlink/lm567c.pdf"><b>NE567</b> (Tone Decoder)</a>, por ejemplo.<br>
<br>
<br>
<b>El receptor, circuito propuesto</b><br>
<br>
Veamos primero si el LM358 nos sirve de verdad o no. En alimentación sencilla (no doble) el LM358 puede funcionar con una tensión mínima de 3V, por esa parte no hay problema si lo alimentamos con 5V. Anda un poco justo pero servirá.<br>
<br>
La tensión de salida en un operacional casi siempre está limitada superior e inferiormente y no puede alcanzar nunca los valores de la alimentación, salvo en el caso de los llamados <em>Rail to Rail</em>. En el datasheet del LM358 se especifica que puede ir desde la alimentación negativa, hasta la positiva menos 1.5V. O sea, en nuestro caso iría desde 0 a 3.5 voltios. Servirá también, aunque viene un poco justo porque 3.5 está muy próximo a la mitad de 5, lo cual reduce nuestro margen de maniobra a tan sólo 1V de amplitud como luego veremos.<br>
<br>
Si hay algo que podría descartar definitivamente el LM358 para operar a 40kHz, es su <b>Slew Rate</b>. Como ya dijimos, es un operacional lento. Tan lento que la salida no puede cambiar más deprisa de 0.3V/us. O sea 300.000V/s.<br>
<br>
<div class="separator" style="clear: both; text-align: center;"></div>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/slew_rate_datasheet.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="184" data-original-width="1024" src="img/slew_rate_datasheet.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Slew Rate y Unity-gain bandwidth para el LM358. Datasheet.</td>
</tr>
</tbody>
</table><br>
Puede parecer muchísimo. ¿A cuanto cambia la tensión en una señal de 40kHz? Permitidme omitir las cuentas. Básicamente se deriva y se busca el máximo. Resulta <a href="https://www.wolframalpha.com/input/?i=max+of+derivative+of+sin(40000*2*pi*t)">251327 V/s</a> por cada voltio de amplitud. Es decir, que para no exceder el <em>slew rate</em> de 300000V/s la amplitud debe ser como mucho 1.19V. Como teníamos antes la limitación de 1V de salida, <b>nos vale</b>.<br>
<br>
¿Y qué pasa si superamos el slew rate? Pues nada, que amplifica menos y distorsiona. Pero como aquí lo que nos interesa es saber si hay señal a la entrada o no, la distorsión nos trae sin cuidado.<br>
<br>
Para el uso que le vamos a dar, no necesitamos ni precisión, ni fidelidad. Decidimos usar el LM358 igualmente; ahora sí, conociendo sus limitaciones.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/sch_receptor2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="842" data-original-width="1600" src="img/sch_receptor2.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Esquema del receptor completo. EyC.</td>
</tr>
</tbody>
</table><br>
La señal captada por el micrófono -o simulada en este caso- alcanza el potenciómetro de volumen <b>POT1</b> y atraviesa dos etapas amplificadoras compuestas por sendos LM358 en cascada. Ambos operacionales están configurados como amplificador inversor con alimentación simple.<br>
<br>
La tensión en la patilla no inversora de <b>U1</b> y <b>U2</b> es igual a la mitad de la tensión de alimentación, es decir 2.5V. Esto lo conseguimos con <b>R1</b> y <b>R2</b> que forman la referencia o tierra virtual. El concepto de <em>tierra virtual</em> ya lo vimos en el artículo <a href="../../../2010/05/preamplificador-microfono-electret/articulo.html">Preamplificador micrófono electret: operacional</a>. <b>C1</b> hace las veces de condensador de desacoplo y <b>C2</b> evita auto-oscilaciones.<br>
<br>
La primera etapa amplificadora, formada por <b>U1</b>, <b>R3</b> y <b>R4</b>, tiene una ganancia de (en teoría) 22. Si el producto ganancia por ancho de banda es realmente 1MHz y operamos a 40kHz, la ganancia máxima para cada etapa sería de 25. Pero si resulta ser menor, 0.7MHz, entonces la amplificación máxima será, como mucho, de 18 y no de 22 veces.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/ampli1.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="735" data-original-width="1246" src="img/ampli1.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Amplificación de la señal de entrada. EyC.</td>
</tr>
</tbody>
</table><br>
La segunda etapa, compuesta por <b>U2</b>, <b>R5</b> y <b>R6</b>, es idéntica a la primera pero con una ganancia de x10. La primera etapa debe ser siempre la de mayor ganancia. Ya que de lo contrario estaríamos amplificando de forma innecesaria el ruido originado por el propio integrado en la etapa anterior.<br>
<br>
<b>U3</b> es un LM393. En el esquema figura LM339, la versión cuádruple, yo he usado el LM393 que es la versión doble del mismo comparador. El LM393 tiene una salida de colector abierto. Esto es, cuando está a nivel bajo se conecta a masa, y cuando está a nivel alto es como si no existiera.<br>
<br>
Fijaos en que a la salida de <b>U2</b> no hay ningún condensador. Esto significa que en la entrada inversora de <b>U3</b> estará presente una tensión continua de 2.5V (mitad de alimentación) más la señal amplificada que no puede superar los 3.5V por limitaciones del amplificador. De ahí nuestro estrecho margen. Una de las limitaciones del circuito.<br>
<br>
Olvidaros por un momento de <b>R10</b>. <b>R8</b> y <b>R9</b> forman un divisor resistivo. En la patilla no inversora de <b>U3</b> habrá una tensión de referencia de 3V. Mientras más próximo a 2.5V más sensible será el receptor pero más ruido captará también.<br>
<br>
Cuando la tensión en la entrada inversora de <b>U3</b> supere el umbral de referencia, su salida se conectará a masa. En ese momento <b>C6</b>, que había estado cargándose principalmente a través de <b>R11</b>, se descargará bruscamente. Y lo de bruscamente es importante, porque cuánto se descargue ya no depende del nivel de señal a la entrada; una vez se supera un umbral, la descarga se produce igual para señales más fuertes o más débiles.<br>
<br>
En este esquema el funcionamiento del condensador <b>C6</b> es inverso a cómo lo hacía en el anterior. Aquí está siempre cargado hasta casi la tensión positiva salvo cuando llega una señal, que se vacía por completo.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/carga-descarga-c.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="734" data-original-width="1246" src="img/carga-descarga-c.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Carga y descarga del condensador de acuerdo a la señal de entrada. EyC.</td>
</tr>
</tbody>
</table><br>
¿Y qué hace <b>R10</b>? Pues es nuestra histéresis. Por cómo está planteado circuito, parte de la tensión en la entrada no inversora de <b>U3</b> depende de la carga de <b>C6</b> en un momento dado. Gracias a esta resistencia, una vez se ha detectado una señal por encima del margen de ruido, este umbral <b>bajará</b>:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/histeresis-dinamica.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="734" data-original-width="1246" src="img/histeresis-dinamica.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Actuación de la histéresis al detectar una señal. EyC.</td>
</tr>
</tbody>
</table><br>
Cuando el transductor capta una señal, esta se amplifica, se compara y acaba descargando el condensador <b>C6</b>. Si la onda supera cierta frecuencia, la descarga se producirá tan a menudo que la carga del condensador se mantendrá por debajo de un cierto nivel mientras ésta dure.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/umbral2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="738" data-original-width="1247" src="img/umbral2.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Umbral del segundo comparador frente a la carga del condensador. EyC.</td>
</tr>
</tbody>
</table><br>
Ahí es donde entra el segundo comparador <b>U4</b>. Fijamos un límite por debajo del cual consideramos que el circuito debe estar activo.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/umbral2-detalle.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="734" data-original-width="1246" src="img/umbral2-detalle.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Detalle del umbral en el segundo comparador. EyC.</td>
</tr>
</tbody>
</table><br>
Cuando la carga de <b>C6</b> es mayor que esta segunda referencia es porque no hay señal a la entrada. La salida de <b>U4</b> está puesta a tierra y en en el punto <em>Out</em> encontraremos una tensión de 0 voltios. Cuando se registre un pulso, bajará la carga del condensador, <b>U4</b> dejará de conducir y la tensión subirá hasta los 3.3V debido al divisor resistivo formado por <b>R14</b> y <b>R15</b>. Nivel apto para conectarlo a una Raspberry por ejemplo.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/output.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="734" data-original-width="1246" src="img/output.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">El receptor transforma los pulsos de entrada en niveles lógicos. EyC.</td>
</tr>
</tbody>
</table><br>
Este es el receptor montado. Se aprecian los integrados <b>LM358</b> y <b>LM393</b>, el operacional y el comparador antes descritos. Así como los conectores para la alimentación, la salida y el micro.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/pcb_receptor.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="442" data-original-width="1305" src="img/pcb_receptor.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Receptor montado en una placa perforada. EyC.</td>
</tr>
</tbody>
</table><br>
<br>
Además, aquí os dejo otra <b>alternativa</b> más. Esta vez sin usar operacionales ni comparadores (al menos no como componentes discretos). Los valores los he puesto un poco a ojo. No la he montado, os recomiendo mejor la anterior.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/sch_alternativa3.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="742" data-original-width="1600" src="img/sch_alternativa3.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Otra posibilidad para el receptor. EyC.</td>
</tr>
</tbody>
</table><br>
En este caso la etapa de entrada está construida con transistores bipolares. <b>Q1</b> está configurado como amplificador en emisor común. La segunda etapa, compuesta por <b>Q2</b> y sus resistencias de polarización, no trabaja linealmente. Su función es entregar a <b>Q3</b> la tensión necesaria para activarse durante un semiciclo de la señal de entrada.<br>
<br>
Usamos el integrado <b>NE555</b> en una configuración que se llama <em>retriggerable monostable</em> y recuerda a la función de <b>C6</b> y el comparador <b>U4</b> en el esquema de la propuesta anterior. En este caso, cuando <b>Q3</b> se activa cortocircuita el condensador.<br>
<br>
La histéresis nos la proporciona el propio integrado con sus patillas <em>trigger</em> y <em>threshold</em>. Cuando la carga de <b>C6</b> (inicialmente 5V) cae por debajo de 1/3 de la alimentación (1.6V aproximadamente) la salida del integrado pasa a nivel alto. Cuando deja de haber señal de entrada, <b>C6</b> puede volver a cargarse y si supera los dos tercios de la alimentación (3.3V) la salida pasa a nivel bajo.<br>
<br>
Probablemente sea preciso afinar los valores de las resistencias. De todas formas la simulación dice que podría funcionar:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/alternativa3_output.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="481" data-original-width="1239" src="img/alternativa3_output.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Funcionamiento del esquema de receptor anterior. EyC.</td>
</tr>
</tbody>
</table><br>
<br>
<b>Firmware del transmisor</b><br>
<br>
Abandonamos ya la electrónica analógica para sumergirnos en lo digital. Dedicaré unas líneas a describir el software del transmisor del cual os pego aquí la parte relevante. El fichero completo lo tenéis en <a href="https://github.com/electronicayciencia/askrecv/tree/master/TX/c">este github</a>.<br>
<br>
Arriba del todo están las funciones de más bajo nivel y al final del archivo la función <em>main</em>. Este estilo se llama <em>bottom-up</em> y ya lo usamos anteriormente en <a href="../../../2017/02/el-bus-i2c-bajo-nivel/articulo.html">El bus I2C a bajo nivel</a> o en <a href="../../../2016/12/el-bus-1-wire-bajo-nivel/articulo.html">El bus 1-Wire a bajo nivel - DS1820</a>. Pero en esta ocasión implementamos un sencillísimo protocolo serie tipo UART.<br>
<br>
De arriba a abajo:<br>
<ul>
<li>Una función que activa o desactiva la generación de portadora PWM poniendo la patilla en modo salida o entrada.</li>
<li>Una función que envía un bit, activando la salida durante un intervalo de tiempo dado.</li>
<li>Una función que envía un byte completo siguiendo un protocolo UART 8O1 (8 bits, paridad impar, 1 bit de parada). Envía primero un bit de start (bit a 0); luego 8 bits sucesivos, empezando por el bit menos significativo; después añade un bit de paridad impar; y finalmente anexa un bit de parada o stop (siempre a uno).</li>
<li>Finalmente la función principal. Define un mensaje, configura el integrado -en especial la frecuencia PWM a 40kHz con un DC de 50%-, activa la transmisión y envía el mismo mensaje byte a byte una y otra vez en bucle a intervalos regulares.</li>
</ul><br>
<pre class="cpp" name="code">void set_line(int1 v) {<br> if (v)<br>  output_high(PWM_PIN);<br> else<br>  input(PWM_PIN);<br>}<br><br>void tx_bit(int1 v) {<br> set_line(v);<br> delay_us(SYMB_TIME_US); <br>}<br><br>/* Transmit a byte:<br> - Set line down, to tx start bit<br> - Wait 1 symbol time<br> - Repeat for BITS<br>   - Set line properly to tx next values<br>   - Wait 1 symbol time between them<br> - Set line to paritiy value<br> - Wait<br> - Set line high to tx stop byte<br> - Wait 1 symbol time  */ <br>void tx_byte(char b) {<br> #bit lsb = b.0;<br> int1 p = 1; // odd parity<br> <br> tx_bit(0);<br><br> char i = 0; // counter <br> while (i &lt; 8) {<br>  tx_bit(lsb);<br>  p = p ^ lsb;<br>  b = b &gt;&gt; 1;<br>  <br>  i++;<br> }<br> <br> tx_bit(p);<br> tx_bit(1);<br>}<br><br>void main()<br>{ <br> const char message[] = <br> "Prueba de comunicacion serie por ultrasonidos.\n";<br> <br> //Configure PWM output<br> // 40kHz 50% PWM config @20MHz<br> setup_timer_2(T2_DIV_BY_1,124,1);<br> set_pwm1_duty((int16)248);<br> <br> // Line UP<br> setup_ccp1(CCP_PWM);<br> delay_ms(500);<br><br> while(TRUE) {<br>  int8 i = 0;<br><br>  while (message[i]) {<br>   tx_byte(message[i]);<br>   i++;<br>  }<br>  <br>  delay_ms(100);<br> }<br>}<br></pre><br>
<br>
El resultado es un tren de pulsos como el siguiente:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/serial_P_100bauds.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="173" data-original-width="1213" src="img/serial_P_100bauds.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Tren de pulsos generado por el transmisor. EyC.</td>
</tr>
</tbody>
</table><br>
Nada más iniciarse empieza a generar la <b>portadora</b> de 40kHz. En este momento, si hubiera un receptor serie al otro lado activaría la señal <a href="https://en.wikipedia.org/wiki/Data_Carrier_Detect">DCD <em>Data Carrier Detect</em></a>.<br>
<br>
Para transmitir un byte lo primero es el bit de <b>start</b>, que siempre es 0. Esto interrumpe la línea y avisa al receptor del comienzo de un mensaje. Después se envían los 8 bits.<br>
<br>
En la imagen se está transmitiendo el código 00001010. Como el orden es <em>LSB first</em> lo debemos invertir, queda transformado en 01010000. Esto es 0x50 hexadecimal o, si lo traducimos a ASCII, la letra 'P'. Es la primera letra del mensaje <em>Prueba de...</em>.<br>
<br>
Sigue el bit adicional de <b>paridad</b> para comprobar errores y finalmente el bit de <b>stop</b>.<br>
<br>
Los demás bits pueden variar, pero el bit de start es siempre 0 y el de stop es siempre 1. Esto implica que la portadora no puede interrumpirse durante más del tiempo que durarían 10 bits. Si eso sucede se llama <b>señal de ruptura</b>. Y puede ser corta, si dura más de un carácter pero menos de dos; o larga si dura 2 o más caracteres. Normalmente la ruptura se produce cuando se pierde la señal porque el otro extremo se desconecta. Lo veremos en el siguiente apartado.<br>
<br>
<br>
<b>Software receptor dedicado</b><br>
<br>
Ahora conectaré el receptor a alguna patilla del conector GPIO en la Raspberry y veré si puedo recibir el mensaje del transmisor.<br>
<br>
Escribiremos un breve programa para recibir e interpretar el tren de pulsos anterior. El código lo tenéis en github, <a href="https://github.com/electronicayciencia/askrecv/blob/master/RX/c/iobits.c">iobits.c</a>. No lo copio aquí pero lo describiré brevemente.<br>
<br>
La función <em>wait_for</em>, dependiendo de sus parámetros, espera a que la línea pase a nivel alto o a nivel bajo. Tiene un tiempo máximo de espera tras el cual finaliza y devuelve un código de error.<br>
<br>
La función <em>main</em> configura la ejecución y comienza un bucle en el que lo primero es buscar la portadora. Para lo cual llama a <em>wait_for</em> y espera hasta que la línea pase a nivel alto. Si no se recibe en unos segundos, el programa termina por <em>timeout</em> con el mensaje <b>NO CARRIER</b>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/putty_no_carrier.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="191" data-original-width="754" src="img/putty_no_carrier.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Si no se detecta la portadora en unos segundos, el programa termina. EyC.</td>
</tr>
</tbody>
</table><br>
Una vez tenemos la portadora fijada, invocamos a la función <em>read_byte</em>. Ahí es donde ocurre todo lo importante.<br>
<br>
Primero aguarda la interrupción de la portadora, indicativo de comiendo de la transmisión. Tras esto lee los 9 bits (8 del carácter, y uno más de paridad). Comprueba si no hay error de paridad, y de haberlo sustituirá el posible carácter erróneo por un signo de interrogación.<br>
<br>
Ahora llama a <em>wait_for</em> nuevamente para esperar a que la línea vuelva a nivel alto con el byte de stop, pues debería ser el siguiente.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/putty_debug.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="350" data-original-width="782" src="img/putty_debug.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Recepción de un byte. EyC.</td>
</tr>
</tbody>
</table><br>
De no volver a línea a nivel alto en el tiempo preestablecido, se considerará como <em>condición de ruptura</em> y devolverá un error (representado por el carácter 0xFF). El programa volverá entonces a la búsqueda de la portadora como inicialmente.<br>
<br>
Si ejecutamos el programa con el transmisor conectado leeremos el mismo mensaje repetido en bucle tal como lo habíamos programado. ¡Estamos transmitiendo información usando ultrasonidos!<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/putty_nodebug.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="712" data-original-width="1224" src="img/putty_nodebug.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Prueba de comunicación serie por ultrasonidos. EyC.</td>
</tr>
</tbody>
</table><br>
<br>
<b>Un poco más allá</b><br>
<br>
Vayamos un poquito más allá del propósito inicial, lo que llaman los ingleses <em>the extra mile</em>.<br>
<br>
Hemos escrito un software para recibir los mensajes y funciona. Es como un <b>puerto serie</b>, pero con ultrasonidos. Sin embargo, al puerto serie físico, uno <em>de verdad</em> podría conectársele una consola tal que así:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/getty_rasp.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="101" data-original-width="1154" src="img/getty_rasp.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">En un puerto serie de verdad se pueden conectar consolas serie. EyC.</td>
</tr>
</tbody>
</table><br>
Mientras que nuestro receptor de ultrasonidos sigue siendo poco más que un interruptor muy rápido para poner una patilla GPIO a 0 o a 1. No puedo conectarle una consola, no puedo interactuar con él mediante ningún terminal serie, en definitiva: no está integrado en el sistema operativo.<br>
<br>
¿Qué se interpone entre un dispositivo hardware y el sistema operativo? ¡Un driver! ¡Hay que escribir un driver para el receptor ultrasónico! Pero trabajar en modo kernel es dolorosamente tedioso, sí, incluso para este blog.<br>
<br>
Afortunadamente encontramos en GitHub un buen proyecto de UART por software. <a href="http://codeintherightway.blogspot.com.es/2017/09/soft-uart-implementation-for-raspberry.html">Soft UART - A UART software implementation for Raspberry Pi</a>. Hace referencia a una lectura imprescindible, muy recomendable si os interesa saber más sobre la programación en modo kernel. <a href="http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/">Writing a Linux Kernel Module</a>.<br>
<br>
El idioma es el de Mordor, que no pronunciaré aquí. En la lengua común implementa un <em>bit banging</em> parecido al que usamos en nuestro software, pero diferente en algunas partes porque un módulo de kernel no puede, por ejemplo, quedarse a la espera como un programa normal. Alrededor de esta implementación, crea un dispositivo de caracteres llamado <b>ttySOFT0</b> asociado a un pin GPIO dado en los parámetros del módulo.<br>
<br>
Tras actualizar Raspbian, instalar las <em>kernel headers</em> y alguna otra cosilla más, compilamos, lo cargamos y...<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/minicom.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="338" data-original-width="1438" src="img/minicom.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Ya podemos usar el receptor por ultrasonidos como un terminal serie. EyC.</td>
</tr>
</tbody>
</table><br>
Ahora tenemos un dispositivo hardware, parte del sistema operativo a todos los efectos. No vamos a conectar una consola serie porque no es bidireccional, pero podríamos.<br>
<br>
<br>
Aquí lo vamos a dejar por hoy. Espero que os haya gustado. Los esquemas y programas los tenéis en este github: <a href="https://github.com/electronicayciencia/askrecv">ASKRECV</a>.<br>
<br>
</div>
<div class='post-labels'>
Etiquetas:
<ul>
<li>amplificadores</li>
<li>circuitos</li>
<li>microcontroladores</li>
<li>programacion</li>
<li>raspberrypi</li>
<li>sonido</li>
</ul>
</div><!-- Above is post content -->
</div><!-- content-inner -->
</div><!-- content-outer -->
<script src="../../../resources/script_bottom.js">
</script>
</body>
</html>

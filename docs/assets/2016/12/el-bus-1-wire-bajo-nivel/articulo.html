<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
<link rel="stylesheet" href="../../../resources/style.css">
<script src="../../../resources/script.js">
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' type='text/javascript'>
MathJax.Hub.Config({
 extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
 jax: ["input/TeX", "output/HTML-CSS"],
 tex2jax: {
     inlineMath: [ ['$','$'], ['$$','$$'], ["\\(","\\)"] ],
     displayMath: [ ["\\[","\\]"] ],
 },
 "HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<title>El bus 1-Wire a bajo nivel - DS1820</title>
</head>
<body>
<div class="content-outer">
<div class="header">
<div class="title">
<h1>Electrónica y Ciencia</h1>
</div><!-- title -->
<div class="description">
<h2>Blog técnico sobre proyectos caseros de electrónica, informática y física.</h2>
</div><!-- description -->
</div><!-- header -->
<div class="content-inner">
<!-- Here the blog content -->
<h3 class='post-title entry-title'>El bus 1-Wire a bajo nivel - DS1820</h3>
<div class='post-date'>
Publicado el 04-12-2016.
</div>
<div class='post-body entry-content'>
Hoy os traigo una entrada sobre el bus 1-Wire y el sensor de temperatura DS1820, con bastante contenido técnico y nivel de detalle, espero que la disfrutéis.<br>
<br>
En la <a href="../../../2016/11/conexion-gpio-de-raspberry-pi-3/articulo.html">entrada anterior</a> vimos cómo manejar de forma básica la conexión <b>GPIO</b> de una Raspberry Pi 3. En esta nos comunicaremos con un sensor digital modelo DS1820, sin utilizar ningún driver ni librería, es decir implementando a <b>bajo nivel</b> el protocolo 1-Wire empleado por el dispositivo.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/ds1820.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/ds1820.jpg"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Sensor digital de temperatura DS18B20.</td>
</tr>
</tbody>
</table><br>
<a name='more' id="more"></a><br>
<br>
<break>
Los DS1820, DS18B20 o DS18S20 son sensores digitales de temperatura. Una especie de LM35 digitales si lo preferís. Sus características principales son una resolución de 9 a 12bit, no requieren componentes externos y se pueden alimentar desde el mismo bus de datos.<br>
<br>
Lo he escogido para esta entrada porque necesitaba medir temperaturas con cierta precisión. Además me ha parecido un ejercicio digno de compartir, que entraña sutilezas técnicas de distinto tipo.<br>
<br>
<br>
<b>Esquema de bloques</b><br>
<br>
El sensor que vais a encontrar más fácilmente es el ds18s20. Es el sucesor del ds1820 ya descatalogado y es totalmente compatible en patillaje y protocolo. El segundo más habitual es el ds18b20, un modelo ligeramente más avanzado que permite escoger la resolución entre 9 y 12 bits. Es compatible en patillaje pero algunos comandos son diferentes.<br>
<br>
Por último, también tenéis a la venta la versión más barata ds1822. Se trata de un modelo económico con mayor margen de error. Si los anteriores tienen un error de más/menos 0.5ºC, en este puede llegar hasta los 2ºC.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/2815.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/2815.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
Esquema de bloques del DS18S20. <a href="https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/DS18S20.html">Maxim integrated</a>.
</td>
</tr>
</tbody>
</table><span id="goog_653410707"></span><span id="goog_653410708"></span><span id="goog_653410711"></span><span id="goog_653410712"></span><br>
En la imagen superior está esquematizado el funcionamiento del sensor. Veamos primero cómo funciona el bloque más a la derecha, el llamado <i>Temperature Sensor</i>.<br>
<br>
Los chips de la familia ds1820 tienen un oscilador cuya frecuencia no depende de la temperatura, es fija. Dicho oscilador actúa como reloj interno y genera pulsos a un ritmo constante. Luego tienen otro oscilador cuya frecuencia sí depende de la temperatura. Mientras el primero genera pulsos a su ritmo, este último determina el tiempo de medición.<br>
<br>
De esta forma contando cuantos pulsos ha generado el primero se puede saber durante cuanto tiempo ha estado abierto el segundo, así es como se calcula la temperatura.<br>
<br>
Bajo este bloque tenemos dos bloques más simbolizando las <b>alarmas</b> programables. Se puede indicar un límite superior e inferior para los cuales el DS1820 responderá a un comando especial. Esta característica se denomina alarma de temperatura. Es muy útil para buscar rápidamente entre muchos sensores si alguno ha excedido los límites sin tener que leerlos todos uno por uno.<br>
<br>
Más abajo está el generador de <b>CRC</b>, hablaremos del CRC más adelante.<br>
<br>
A su izquierda está el bloque llamado <b>scratchpad</b>. Es un registro que podemos leer y escribir por comandos. Lo usaremos para leer la temperatura. Este registro se comunica mediante la lógica de control con la ROM y el puerto 1-Wire.<br>
<br>
La <b>ROM</b> es una memoria de sólo lectura donde está el número de serie del dispositivo. En cualquier bus donde hay más de un receptor conectado, se necesita una forma de identificar al destinatario. En un bus SPI tenemos una línea dedicada <i>Slave Select</i>. En un I2C tenemos un código mitad fijo, mitad personalizado. Los dispositivos 1-Wire tienen un <b>número de serie</b> de 64bit que los identifica por si hubiera varios sensores conectados al mismo bus.<br>
<br>
El formato del número de serie es como sigue:<br>
</break><br>
<ul>
<li>Identificador de la <b>familia</b>: siempre será 10h para DS1820 y DS18S20. 28h para DS18B20 y 22h para el DS1822. Este código nos dice el tipo de chip conectado, podrían ser sensores, números de serie digitales, interruptores, memorias, etc.</li>
<li>Número de <b>serie</b> propiamente dicho, 48 bit. Con 48 bits hay espacio para 10<sup>14</sup> identificadores diferentes por lo que la probabilidad de colisión es mínima.</li>
<li>Finalmente un byte de <b>CRC</b>. Cuando se transmiten datos a menudo algún bit se pierde por el camino o se invierte. Un CRC es el resultado de una operación matemática que se aplica en el emisor con todos los bits anteriores. Luego la reproduce el receptor para comprobar si el mensaje ha llegado con alteraciones. Más abajo lo explicaremos con detalle.</li>
</ul><br>
A la hora de lanzar un comando podemos hacerlo indicando el identificador al que va dirigido. También hay un comando especial que omite la dirección y selecciona todos los esclavos conectados. Como a priori no sabemos los códigos, hay un algoritmo para que el maestro descubra los identificadores de los esclavos conectados al bus. Sin embargo, como para este artículo emplearemos un sólo sensor no será necesario.<br>
<br>
El último bloque es la fuente de energía <i>parásita</i>. Cada chip 1-wire tiene un condensador que se carga a través del positivo de alimentación si está conectado. Si no está conectado el positivo, entonces se carga mediante la linea de datos cuando está en nivel alto. El bus 1wire es de colector abierto con resistencias de pull-up, por tanto la línea de datos está a nivel alto la mayor parte del tiempo. Cuando el bus pasa a nivel bajo el chip se alimenta de la carga almacenada por el condensador.<br>
<br>
En cierto modo me recuerda un poco a los chips RFID en esta forma de extraer energía del propio lector. Como consecuencia el positivo de alimentación es opcional. Junto a la masa común, tan sólo necesitan un cable para alimentación y datos. De ahí el término <b>1-Wire</b>.<br>
<br>
Ahora quisiera contaros algo de su "<b>lado oscuro</b>". Gracias a su bajo coste, pequeño tamaño y número de serie propio, se utilizan muchísimo para la identificación de piezas originales. Por ejemplo en los adaptadores de tensión de portátiles.<br>
<br>
<a href="http://www.righto.com/2013/06/teardown-and-exploration-of-magsafe.html">Teardown and exploration of Apple's Magsafe connector</a>. Dentro del conector <i>MagSafe</i> de un Mac hay un chip 1Wire modelo DS2413, un doble interruptor capaz de controlar hasta 20mA. Es barato y muy práctico para encender y apagar el LED del conector. Pero la misma tecnología resulta igual de práctica para rechazar cargadores no originales.<br>
<br>
Es el caso de los cargadores para portátiles Dell, <a href="http://www.laptop-junction.com/toast/content/inside-dell-ac-power-adapter-mystery-revealed">Inside the DELL AC Power Adapter - A mystery revealed</a>. Cada cargador Dell tiene un chip DS2501 (o DS2502). Se trata de memorias EPROM. Es decir, memorias que se pueden escribir pero no se pueden borrar. El fabricante guarda ahí los datos referidos al adaptador: la tensión, el tipo de cargador, o la potencia máxima sobre todo. El portátil lee dichos datos y determina si es compatible o no. Si no es compatible interrumpe la carga por precaución. De ahí que sólo se puedan usar cargadores originales.<br>
<br>
Y sucede lo mismo con las baterías. El integrado DS2438 es un monitor inteligente de baterías. Controla el nivel de carga, la corriente consumida o la temperatura. Adicionalmente dispone de una EEPROM de 40 bytes donde el fabricante escribe el tipo de batería, fabricante, número de serie, fecha de fabricación, etc. Por un lado es perfecto para controlar en todo momento el estado de la batería y prevenir accidentes, pero por otro lado hace que el dispositivo sólo funcione con baterías originales.<br>
<br>
<br>
<b>El protocolo 1-Wire</b><br>
<br>
Hay dos tipos de bus serie: los que tienen una linea de reloj dedicada y los que no.<br>
<br>
Como ejemplo del primer tipo tenemos los buses SPI o I2C, con una linea de datos y otra independiente para sincronización. La ventaja es que la transmisión es más simple, más rápida y más fiable. Pero necesitamos un cable extra para el reloj.<br>
<br>
Necesitar un hilo más no parece un gran problema para la comunicación Entre Circuitos Integrados (I2C), o para los Periféricos Serie (SPI). Pero... ¿y si sólo tuviéramos un canal y no hubiera forma de tener una señal de reloj paralela? Tal es el caso de un mando a distancia infrarrojo, una antena, un telégrafo, un CDROM, un cable telefónico o una banda magnética.<br>
<br>
Imaginad que para transmitir un 1 damos tensión a la línea durante un tiempo y para el 0 la quitamos. Ahora imaginad que transmitimos muchos 0 seguidos. El receptor no tiene forma de saber si le están transmitiendo 0 todo el rato, si han apagado el receptor, o si se ha cortado el cable.<br>
<br>
Para evitarlo, en lugar de "tensión para 1, no tensión para el cero" se puede recurrir a invertir el voltaje. Por ejemplo 12V para 0 y -12V para el uno. Se llama codificación bipolar.<br>
<br>
Aún así queda otro problema. Cuando se transmite mucho tiempo el mismo estado. Como el reloj del transmisor y del receptor no son perfectos cada uno tendrá una deriva diferente. Al cabo del tiempo la desincronización habrá llegado a la duración de un bit y se habrá perdido la cuenta de cuántos van. Esta condición se llama bit-slipping y es propia de las codificaciones <i>Non Return to Zero</i>.<br>
<br>
La mejor forma de solucionarlo es haciendo que la linea cambie de cuando en cuando siguiendo un patrón para que el receptor pueda ajustar su reloj y no se pierda. Hay codificaciones que en cada bit, sea cual sea su valor, cambian una vez. Estas codificaciones reciben el nombre de <i>Self clocking</i> porque reúnen los datos y el reloj en la misma señal.<br>
<br>
El protocolo <b>1 Wire</b> está diseñado teniendo en cuenta lo anterior, y además para que la linea de datos se mantenga en nivel alto el mayor tiempo posible.<br>
<br>
Consiste en una especie de código morse. En reposo la linea se mantiene a nivel alto mediante una resistencia de pull-up. El valor recomendado es 5k. Menos de lo habitual para las resistencias de pull-up. Esta resistencia debe ser baja para cargar el condensador de alimentación como vimos antes. Si la resistencia fuese muy alta, el condensador tardaría mucho en cargarse y sólo se podrían transmitir señales de forma muy lenta para no reiniciar los chips.<br>
<br>
De todas formas el tiempo que tarda la linea en recuperarse depende de varios factores; como la resistencia de pull-up, la longitud del cable, el número de dispositivos conectados y si utilizan el positivo para alimentación o el mismo cable de datos.<br>
<br>
1-Wire tiene cinco componentes básicos:<br>
<br>
<b>Presencia</b>. El máster lleva el bus a nivel bajo durante entre 480 y 600us. El condensador se descarga y como resultado todos los dispositivos conectados se reinician. Acto seguido el máster libera la linea, y esta vuelve a nivel alto. Los esclavos 1-Wire al iniciar esperan un momento y llevan el bus a nivel bajo. Así el máster determina que hay al menos un elemento 1Wire conectado. A esa secuencia se le llama presencia.<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/1w-presence.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/1w-presence.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Secuencia de reinicio. En azul el pulso de presencia.</td>
</tr>
</tbody>
</table><br>
<b>Escribir 0 y escribir 1</b>. Es parecido al código morse. Para escribir un dato el máster lleva a cero el bus durante un breve periodo. Si es un poco más de 1us y hasta 15us el receptor interpreta un 1. Si es más largo, 60us, el receptor interpreta un cero.<br>
<br>
El mecanismo realmente es más sencillo. Cuando el receptor detecta que la tensión ha caído a 0, espera entre 15 y 45us y vuelve a comprobar la linea. Si para entonces ha vuelto a nivel alto se trata de un 1, si continúa en nivel bajo, entonces se trata de un 0. Tras escribir un bit hay que esperar un tiempo de reposo. Dicho tiempo recibe el nombre de <i>timeslot</i>, y está entre 60 y 120us.<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/1w-w1w0.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/1w-w1w0.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Escritura por el máster de 1 y 0.</td>
</tr>
</tbody>
</table><br>
<b>Leer 0 y leer 1</b>. Según el diseño del bus 1-Wire, el máster es quien inicia la lectura. Cuando el máster quiere leer transmite un pulso breve, como si fuera a enviar un 1. Espera unos instantes y muestrea. Si el chip quiere transmitir un uno, no hará nada, dejará que la linea suba y el máster al tomar el valor leerá un uno. Si el chip quería transmitir un 0 mantendrá la linea sujeta durante unos 15us. En tal caso cuando el máster vuelva a mirar el valor, leerá cero.<br>
<br>
El máster debe muestrear el estado del bus tras el tiempo de recuperación, siempre antes de los 15us, y anotar el valor leído.<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/1w-r1r0.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/1w-r1r0.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Pulsos de lectura. En azul la reacción del esclavo.</td>
</tr>
</tbody>
</table><span id="goog_653410727"></span><span id="goog_653410728"></span><span id="goog_653410729"></span><span id="goog_653410730"></span><br>
<br>
<b>Esperar microsegundos</b><br>
<br>
Llevamos unos párrafos hablando de microsegundos. ¿Hasta qué punto es viable hacer esperas tan cortas?<br>
<br>
Aún en el <b>PIC</b> más básico, funcionando a 4MHz, tenemos una instrucción cada microsegundo. Esperar 10 microsegundos en un microcontrolador es inmediato, serían 10 instrucciones. Esperar 10 microsegundos en un sistema multitarea como una Raspberry es <b>imposible</b>. Porque aún ejecutando muchas más instrucciones por segundo, no hay forma de saber cuándo se van a ejecutar, ni si la ejecución va a ser continua o interrumpida.<br>
<br>
Vas a acabar esperando 5, 12 o 7us pero no los 10us exactos.<br>
<br>
Para eso están los sistemas de <i>Tiempo Real</i>. No os dejéis engañar por el nombre, la característica principal de un sistema Tiempo Real no es su velocidad de respuesta, es que es <b>predecible</b>. Un sistema Tiempo Real puede demorarse 20ms en dar una respuesta. Pero siempre se demorará esos 20ms más o menos. Y no unas veces 10ms y otras veces 500.<br>
<br>
Linux, como decíamos, no es así. Es un sistema multitarea donde una actividad tiene un tiempo asignado de CPU. Dicho tiempo se interrumpe varios miles de veces por segundo para ejecutar otras tareas con mayor o menor prioridad. Lo más que nos pueden garantizar las funciones de espera es no continuar hasta haber transcurrido <b>al menos</b> el tiempo deseado. Pero puede ser más, y casi siempre suele ser más.<br>
<br>
El protocolo 1wire tiene unas especificaciones de tiempo concisas. Como el programa lo vamos a hacer en C, apoyándonos en la librería WiringPi, nos fijamos en la función <i>delayMicroseconds</i>. Esta función espera un determinado número de microsegundos antes de continuar la ejecución.<br>
<br>
Como ya sabemos que siempre va a esperar más de la cuenta, vamos a hacer un pequeño programa que haga miles de llamadas de espera y cronometre el tiempo transcurrido en realidad. Hemos medido el tiempo de espera para valores entre 0 y 300us en 100000 iteraciones.<br>
<br>
<pre>t       min     avg     max     var<br>0       0       0.88    69      0.41<br>50      0       1.92    298     10.79<br>100     38      68.83   9691    1605.88<br>150     32      68.55   3208    341.54<br>200     32      68.90   13989   3197.04<br>250     33      69.00   8561    1488.61<br>300     24      69.07   10294   1967.54<br></pre><br>
Aquí <b>t</b> es el tiempo de espera solicitado en us, el argumento de la función si queréis. Los demás valores se refieren al exceso de tiempo esperado respecto a t. O sea, si pido esperar 100 y acabo esperando 138, el error es 38us.<br>
<br>
<b>min</b> es el error más pequeño de todas las iteraciones para un tiempo dado. <b>avg</b> la media de los errores. <b>max</b> es el máximo exceso que hemos medido y <b>var</b>, como podéis intuir, la desviación típica.<br>
<br>
Volviendo a leer la tabla, un momento... si pido esperar 200us, podría esperar 232 como poco y hasta <b>más de 14ms</b> en algún caso. ¡Es una incertidumbre altísima! Podríamos resumirlo como "tú pide lo que quieras, y yo esperaré lo que me apetezca".<br>
<br>
¿Y si le damos mayor prioridad al programa? Cuando varios programas reclaman el uso de la CPU, el que tiene mayor prioridad recibe una rodaja de tiempo más grande, o más rodajas de tiempo en promedio. Con el comando <i>nice</i> podemos especificar una prioridad mayor.<br>
<br>
Pero aquí no hablamos de consumo de CPU, sino de tiempo de espera. Los mayores errores se producen cuando está a punto de terminar el contador pero la tarea se aparca para atender otros programas ligados a la misma CPU. Para cuando la CPU retoma la tarea, el tiempo ya se ha excedido.<br>
<br>
Desde aproximadamente el año 2008 Linux incorpora ciertas características imitando a un sistema Real-Time. En concreto, la programación de tareas llamada <b>FIFO</b> consiste en que una tarea no abandona la CPU mientras siga usándola. Este comportamiento puede volver el sistema inestable si un programa adquiere la CPU con prioridad máxima, ya que impedirá que se ejecuten otros programas asignados a la misma CPU. Por eso sólo el administrador puede asignar tal prioridad.<br>
<br>
El comando <i>chrt</i> nos permite modificar el programador de tareas, así con <b>chrt -f 99</b> estamos indicando que queremos el programador Real-Time FIFO con prioridad 99.<br>
<br>
Este es el efecto sobre el programa anterior:<br>
<br>
<pre>t       min     avg     max     var<br>0       0       0.85    45      0.16<br>50      0       1.73    55      2.19<br>100     6       15.46   154     7.45<br>150     6       15.43   96      7.13<br>200     6       15.42   101     7.39<br>250     6       15.45   74      6.94<br>300     6       15.47   122     7.78<br></pre><br>
La incertidumbre ahora es mucho más baja; y el error máximo al menos es del mismo orden de magnitud. Además, ahora el mejor caso se aproxima mucho más a tiempo de espera real.<br>
<br>
La librería WiringPi tiene una función llamada <i>piHiPri ()</i>. Funciona igual que si ejecutáramos el comando <i>sudo chrt -r 99</i>. Asigna a la tarea la máxima prioridad asignable por el usuario sólo que, en lugar el programador FIFO, emplea el programador de Tiempo Real RoundRobin, pero el resultado es el mismo.<br>
<br>
Aún así hay dos casos bien diferenciados: por encima y por debajo de 100us, fijaos en la media. Para valores por debajo de 100us, en algún caso el error ha sido 0 y el error medio anda entre 1 y 2us de margen. Para valores superiores, en cambio, el mínimo error que podemos esperar es 6us. Es decir, jamás esperaremos exactamente el tiempo previsto, siempre esperaremos como poco 6us más y, en general, 15 o 16us más.<br>
<br>
Encontramos la razón mirando el código de WiringPi. Cuando el tiempo de espera es inferior a 100us <i>delayMicroseconds</i> utiliza un bucle para esperar. Esta técnica se llama busy waiting y mantiene el procesador al 100% mientras espera. Para no mantener el procesador al 100% durante más tiempo del necesario, para tiempos mayores de 100us hace uso de la función <i>nanosleep</i>. La cual, como vemos, nos hace esperar en promedio 15us más.<br>
<br>
En la siguiente imagen se aprecia mucho mejor el salto. En el eje horizontal están los tiempos de espera solicitados hasta 500us. En el eje vertical el exceso de espera. En color azul los casos comprendidos entre el mínimo y el máximo error. Y en gradiente una distribución normal con la media y la varianza obtenidas. Si bien no tenemos garantía de que la distribución de los errores siga una normal, con una varianza pequeña nos sirve para hacernos una idea.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/microseconds_distr_100000.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/microseconds_distr_100000.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Tiempos esperados con 100.000 iteraciones. Click para ampliar.</td>
</tr>
</tbody>
</table><br>
<br>
Podemos forzar la espera en bucle llamando a la función <i>delayMicrosecondsHard</i>. Este es el resultado:<br>
<br>
<pre>t       min     avg     max     var<br>0       0       0.87    19      0.14<br>50      0       0.01    17      0.03<br>100     0       0.01    35      0.04<br>150     0       0.01    18      0.06<br>200     0       0.01    22      0.05<br>250     0       0.01    40      0.05<br>300     0       0.01    26      0.08<br></pre><br>
Ya lo veis, un error promedio <b>menor de 1us</b> en todos los casos y un máximo de 40us. Con estos márgenes <b>sí</b> funcionará la comunicación 1-Wire.<br>
<br>
<br>
<b>Primitivas de 1-Wire</b><br>
<br>
Ahora vamos a usar el bus para transmitir y recibir.<br>
<br>
Aunque nosotros lo vamos a hacer desde cero, hay un módulo del kernel que sirve para comunicarse con el ds1820. El procedimiento lo tenéis en multitud de páginas, por ejemplo <a href="https://www.modmypi.com/blog/ds18b20-one-wire-digital-temperature-sensor-and-the-raspberry-pi">DS18B20+ One Wire Digital Temperature Sensor and the Raspberry Pi</a> o también <a href="https://learn.adafruit.com/adafruits-raspberry-pi-lesson-11-ds18b20-temperature-sensing?view=all">Adafruit's Raspberry Pi Lesson 11. DS18B20 Temperature Sensing</a>.<br>
<br>
Para elaborar el programa seguiremos un esquema de desarrollo <i>bottom-up</i>, empezando por las funciones más básicas y terminando en la función <i>main</i>.<br>
<br>
En esta sección no vamos a entrar en los comandos del protocolo. Nos limitaremos al control eléctrico del bus de datos y a leer y escribir bits.<br>
<br>
La primera función se llamará <b>low</b> y sirve para llevar el bus a cero durante un periodo de tiempo dado. Recordad que la linea de datos se encuentra por defecto en nivel alto debido a la resistencia de pull-up.<br>
<br>
Para eso definimos la patilla como salida, hasta ahora en estado de alta impedancia (entrada), y escribimos un 0 lógico. A continuación esperamos el tiempo especificado y la volvemos a poner como entrada.<br>
<br>
<pre class="cpp" name="code">/* Pulls down the bus for given us then releases it */<br>void low(int pin, int us) {<br> pinMode (pin, OUTPUT);<br> digitalWrite (pin, LOW);<br> delayMicrosecondsHard (us);<br> pinMode (pin, INPUT);<br> delayMicrosecondsHard (TREC);<br>}<br></pre><br>
Aquí entra en juego un parámetro al que hemos llamado <i>TREC</i>. Significa Tiempo de Recuperación y quiere decir cuánto tarda nuestro bus en recuperarse.<br>
<br>
Los dispositivos 1-wire incorporan un condensador cuya capacidad depende del modelo. El tiempo de recuperación va a depender de multitud de factores, como por ejemplo cuántos esclavos hay conectados al mismo bus, la longitud de este, su resistencia y capacitancia, el valor de la resistencia de pull-up o de si empleamos alimentación externa o parásita.<br>
<br>
En nuestro caso, el tiempo de recuperación es bajo porque conectamos la alimentación externa. Las resistencias de pullup incorporadas en la Raspberry son de 50kOhm, y lo recomendado es 5kOhm. Por tanto, si no queremos usar componentes externos debemos conectar el pin de alimentación. Hemos definido TREC igual a 2us, por ejemplo.<br>
<br>
Lo más fácil de escribir a continuación es la secuencia de <b>presencia</b>. Si recordáis, consiste en retener la linea a 0V durante más de 480us. Según dice el datasheet los dispositivos pueden aguantar sin corriente entre 480 y 960us. Luego 960us es el tiempo que debemos esperar para garantizar que todos los dispositivos se han reiniciado.<br>
<br>
A continuación, según vemos en la imagen, los esclavos esperan entre 15 y 60us y ellos mismos llevan la línea a 0V durante un breve tiempo. Suficiente para medirlo sin dificultad.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/1w-presence.datasheet.PNG" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/1w-presence.datasheet.PNG"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Secuencia de reinicio. Datasheet DS1820. Dallas Semiconductor.</td>
</tr>
</tbody>
</table><br>
<br>
Así pues, bajamos el bus durante 960us, esperamos 60 y leemos. Si hemos leído un nivel bajo significa que hay algo conectado (devolveremos 1). De lo contrario no hay nada en el bus (devolveremos 0). En otras palabras, devolvemos lo contrario al valor leído.<br>
<br>
Por último damos un tiempo prudencial para que los dispositivos se inicien correctamente según sugiere la imagen. 300us será suficiente.<br>
<br>
<pre class="cpp" name="code">/* Sends a reset pulse and waits for a presence response */<br>int reset (int pin) {<br> int v;<br> <br> low (pin, 960);<br> delayMicrosecondsHard (60);<br> v = digitalRead(pin);<br> delayMicroseconds(300); <br> <br> return !v;<br>}<br></pre><br>
<br>
Lo siguiente será una función para transmitir un bit 0 o 1, la llamaremos <b>send_bit</b>. Tal como habíamos visto, para enviar un <b>cero</b> el máster debe llevar la línea a nivel bajo durante el tiempo que dura un <i>timeslot</i>, entre 60 y 120us.<br>
<br>
Para enviar un <b>uno</b>, el máster debe bajar la linea durante un tiempo minúsculo de entre 1 y 5us y luego liberarla hasta el siguiente timeslot, o dejarla así si no va a enviar más datos. En el datasheet recomiendan más de 1us y menos de 15. Como las rutinas de espera siempre esperan más de lo necesario, programamos 2us por ejemplo.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/1w-writing.datasheet.PNG" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/1w-writing.datasheet.PNG"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Secuencia para escritura. Datasheet DS1820. Dallas Semiconductor.</td>
</tr>
</tbody>
</table><br>
<br>
Así es como funciona en la práctica: el chip 1-Wire detecta la bajada de la linea, espera entre 15 y 60us y lee el estado del bus. Si es positivo entiende un 1 y si es negativo entiende 0. Ya está. No olvidéis que si la dejamos en 0 durante mucho tiempo, más de 480us, a los chips se les agota el condensador y se reinician.<br>
<br>
TIMESLOT es una variable del programa. No es crítica, en la práctica funciona desde 25us en adelante. El datasheet recomienda un mínimo de 60us y un máximo de 120, nosotros hemos decidido fijarla en 90us.<br>
<br>
<pre class="cpp" name="code">/* Sends a 0 by pulling the bus for a whole time slot<br> * Sends a 1 by pulling just a bit 5ms,<br> * and then releasing it for the rest of time slot */<br>void send_bit(int pin, int bit) {<br> if (bit) {<br>  low(pin,2);<br>  delayMicrosecondsHard(TIMESLOT-5);<br> }<br> else {<br>  low(pin,TIMESLOT);<br> }<br>}<br></pre><br>
<br>
Lo siguiente es <b>leer</b> un bit. Para leer un bit el máster debe llevar la línea a nivel bajo durante más de un microsegundo. El dispositivo detecta la bajada. Cuando el máster libera la línea pueden pasar dos cosas: si el esclavo quiere escribir un 1 libera la línea y vuelve a nivel alto, pero si quiere escribir 0 la retiene en nivel bajo hasta 15us.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/1w-reading.datasheet.PNG" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/1w-reading.datasheet.PNG"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Secuencia de lectura. Datasheet DS1820. Dallas Semiconductor.</td>
</tr>
</tbody>
</table><br>
<br>
Así pues, en esta rutina bajamos el bus durante dos microsegundos, e inmediatamente leemos el valor. Devolvemos el valor leído. La rutina <i>low</i> ya esperaba el tiempo necesario para la recuperación del nivel.<br>
<br>
<pre class="cpp" name="code">/* Sends a brief pulse and then read for the response */<br>int read_bit(pin) {<br> int s;<br><br> low(pin, 2);<br> s = digitalRead(pin);<br> delayMicrosecondsHard(TIMESLOT);<br><br> return s;<br>}<br></pre><br>
<br>
Una vez que escribimos y leemos bits, es sencillo escribir o leer un byte. Únicamente hay que escribir o leer 8 bits seguidos.<br>
<br>
Pero eso sí, prestad atención al <b>orden</b> en que enviamos los bits. Los dispositivos 1-Wire siempre empiezan enviando el bit menos significativo primero. La siguiente función <b>send_byte</b> llama varias veces a <b>send_bit</b> con el valor que tenga el bit menos significativo del byte. Tras haber enviado un bit, desplaza hacia la derecha el valor y repite.<br>
<br>
<pre class="cpp" name="code">/* Sends 8 bit in a row, LSB first */<br>void send_byte(int pin, char byte) {<br> int i;<br><br> for (i = 0; i &lt; 8; i++) {<br>  send_bit(pin, byte & 1);<br>  byte = byte &gt;&gt; 1;<br> }<br>}<br></pre><br>
<br>
Para leer es algo más complicado, ya que tenemos que empezar a leer por el bit menos significativo. El primer bit leído irá a la derecha del todo. El siguiente irá a su izquierda, y así iremos rellenando los 8 bits hasta componer un byte.<br>
<br>
<pre class="cpp" name="code">/* Reads a byte, LSB first */<br>char read_byte(pin) {<br> int byte = 0;<br> int i;<br><br> for (i=0; i &lt; 8; i++) {<br>     int b;<br>  b = read_bit(pin);<br>  b = b &lt;&lt; i;<br>  byte = byte | b;<br> }<br><br> return byte;<br>}<br></pre><br>
<br>
<br>
<b>CRC-8 Maxim/Dallas</b><br>
<br>
Como ya hemos visto el protocolo es crítico en tiempos. ¿Qué pasa si falla? Pues que podemos enviar o recibir datos erróneos. ¿Forma de detectarlo? Hay varias.<br>
<br>
La más sencilla, que no se usa aquí, es el bit de paridad. En el caso de una transmisión serie, por ejemplo se usa un bit de paridad para detectar errores. Por si no os habéis parado a pensar cómo funciona, se fuerza a que el número de unos sea par o impar añadiendo un bit a 1 o a 0 según haga falta. Cuando se recibe el byte, se comprueba que el número de unos corresponde a lo acordado y si no, pues ha habido un error.<br>
<br>
El bit de paridad, siendo tan básico, sólo permite detectar un número impar de errores. En cuanto se cambien dos bits, ya lo da como correcto. De hecho en transmisión serie es habitual que fallen varios bits seguidos debido alguna interferencia.<br>
<br>
En otros ámbitos, sobre todo cuando el mensaje es numérico, se recurre a calcular el resto módulo algún valor. Por ejemplo en el cálculo de la letra del DNI se utiliza el resto módulo 23.<br>
<br>
El CRC es una forma de calcular el resto un tanto especial. No voy a explicar el fundamento matemático porque daría para un artículo entero. Pero básicamente funciona con un registro de desplazamiento por el que pasan todos los bits. A medida que se desplazan de un lugar a otro, pueden invertirse o no dependiendo del nuevo bit y del resultado del bit anterior.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/crc8.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/crc8.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">CRC8 para 1wire. Datasheet DS1820. Dallas Semiconductor.</td>
</tr>
</tbody>
</table><br>
<b>¿Un lío?</b> Sí, precisamente. Se trata de hacer una operación enrevesada con la intención de hacer improbable que una cascada de errores aleatorios dé casualmente el mismo resultado.<br>
<br>
La idea es esa, sí. Realmente hay un fundamento matemático muy robusto detrás basado en el álgebra de polinomios. Lo importante aquí son dos cosas:<br>
<ul>
<li>Es fácil de <b>implementar</b>. Para el hardware actual, desplazar bits y hacer xor son de las operaciones más baratas y más rápidas.</li>
<li>Es fácil de <b>comprobar</b>, de hecho no hace falta. Me explico. Por la naturaleza matemática de un CRC, si concatenamos el valor al mensaje original, cuando calculemos el CRC de todo junto va a dar cero. O sea, al recibir un mensaje incluyendo el CRC tan sólo hemos de pasarlo por la misma rutina que calcula CRC y mirar el resultado. Si es cero, entonces el mensaje no tiene ningún error.</li>
</ul><br>
Ejemplo. Tenemos un programa que calcula el CRC8 del argumento que se le pase. Y nos da el resultado en hexadecimal y su carácter correspondiente.<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">./crc ElectronicaYciencia</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">25h '%'</span><br>
<br>
El CRC correspondiente al mensaje "ElectronicaYciencia" es el 25h, equivalente al carácter '%'. Si ahora calculamos el CRC de ElectronicaYciencia añadiendo el caracter "%" este es el nuevo resultado:<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">./crc ElectronicaYciencia%</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">00h ''</span><br>
<br>
Cero. Significa que el mensaje está íntegro. Probamos de nuevo:<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">./crc "Esto es un mensaje de prueba. ¿Llega bien?"</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">53h 'S'</span><br>
<br>
Ahora añadiendo la letra "S" al final:<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">./crc "Esto es un mensaje de prueba. ¿Llega bien?S"</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">00h ''</span><br>
<br>
El resultado es cero. El mensaje está bien. Probemos a introducir algún error. Por ejemplo cambiando cualquiera de las letras.<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">./crc "Esto es un mensa)e de prueba. ¿Llega bien?S"</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">E9h '�'</span><br>
<br>
El CRC deja de ser 0 y sabemos que hay algún <b>fallo</b>. Ciertos CRC tienen la capacidad de detectar el error y corregirlo. No es el caso.<br>
<br>
Hay múltiples parámetros al implementar el algoritmo, cada fabricante usa el suyo. Se distinguen por el tamaño (8bit, 16bit, 32bit, etc) y también por lo que se llama <i>polinomio generador</i>. Que viene a ser la forma de intercalar los XOR en el registro de desplazamiento que veíamos antes.<br>
<br>
Este es el código para generar y validar el CRC usado en los dispositivos 1Wire de Maxim/Dallas:<br>
<br>
<pre class="cpp" name="code">/* Calculates CRC8-Maxim according datasheet<br> * If CRC is appended at the end of string, correct array gives result 00 */<br>unsigned char crc8 (char *str, size_t len) {<br> char div = 0b10001100; // Rotated poly<br> unsigned char crc = 0;<br><br> size_t i;<br> for (i = 0; i &lt; len; i++) {<br>  unsigned char byte = str[i];<br><br> int j;<br>  for (j = 0; j &lt; 8; j++) {<br><br>   // Shift CRC<br>   char crc_carry = crc & 1;<br>   crc &gt;&gt;= 1;<br><br>   // Shift Byte<br>   char byte_carry = byte & 1;<br>   byte &gt;&gt;= 1;<br><br>   // If crc_carry XOR byte_carry we make crc XOR div<br>   if (crc_carry ^ byte_carry)<br>    crc ^= div;<br>  }<br> }<br><br> return crc;<br>}<br></pre><br>
El código anterior no es evidente ni mucho menos. En esta página tenéis el descrito proceso, os ayudará a comprenderlo: <a href="http://www.datastat.com/sysadminjournal/maximcrc.cgi">Eric's Maxim/Dallas 1-Wire Online CRC Calculator</a>.<br>
<br>
<br>
<b>Leer la ROM</b><br>
<br>
Ya podemos escribir comandos y leer los resultados, comprobando que están bien. Como primera prueba leeremos su número de ROM. Hay dos formas de hacerlo:<br>
<ul>
<li><b>la fácil</b>, cuando tan solo hay un dispositivo en el bus. Se le envía el comando 33h y el chip devuelve 8 bytes seguidos con su identificación.</li>
<li>Y luego está <b>la difícil</b>, cuando hay más de un esclavo. Si pedimos la ROM igual que antes, todos los esclavos contestarán a la vez y así no hay forma de entender nada.</li>
</ul>En el segundo caso hay un algoritmo que puede usar el máster. Sirve para "descubrir" la identificación de todos los dispositivos conectados. Es algo difícil de captar la primera vez, pero si tenéis interés está muy bien explicado en el datasheet. Además es muy ingenioso. Yo creo que vale la pena echarle un vistazo.<br>
<br>
De momento vamos al primer caso. Un sólo DS1820 conectado. Enviamos el comando 33h <i>READ ROM COMMAND</i> y a continuación leemos los 8 bytes que devuelve:<br>
<br>
<pre class="cpp" name="code">/* Reads ROM, void function just for testing */<br>void read_rom(int pin) {<br> char rom_data[8];<br><br> puts ("Reading ROM data (Cmd 33h)");<br> send_byte(pin, 0x33);<br><br> int i;<br> for (i = 0; i &lt; 8; i++) {<br>  rom_data[i] = read_byte(pin);<br>  printf("%02x ", rom_data[i]);<br> }<br><br> if (crc8(rom_data, 8)) {<br>  puts("\tROM data read ERROR.");<br>  exit(0);<br> }<br> else {<br>  puts("\tOK");<br> }<br><br> reset(pin);<br>}<br></pre><br>
Observad cómo tras leer 8 bytes e imprimirlos hemos llamado a la función <b>crc</b>. Así determinamos si ha habido algún error en la recepción. Finalmente llamamos a la función <b>reset</b>. Siempre se debe reiniciar el bus entre una orden y la siguiente.<br>
<br>
El resultado es este:<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Reading ROM data (Cmd 33h)</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">10 8c 67 e3 01 08 00 30 OK</span><br>
<br>
Desglosado de esta manera:<br>
<ul>
<li>Código de la familia, 1 byte. 10h es el indicador de DS1820 o DS18S20.</li>
<li>Código de identificación, 6 bytes (64bit). 8c67e3010800.</li>
<li>CRC del mensaje, 1 byte. 30 es el CRC correcto, por eso pone OK.</li>
</ul><br>
En ocasiones por unas causas o por otras el mensaje puede llegar mal, por ejemplo así:<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Reading ROM data (Cmd 33h)</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">10 8c 67 e3 01 0a 00 30 ROM data read ERROR.</span><br>
<br>
El byte 08h anterior (0000 1000 en binario) lo hemos leído como 0ah (0000 1010). Al haber cambiado uno de los bits del mensaje, el crc ya no coincide y el error se detecta.<br>
<br>
<br>
<b>Leer la temperatura</b><br>
<br>
Al igual que antes, asumiremos un sólo DS1820 conectado. La lectura de la temperatura se lleva a cabo en dos pasos. Primero se lanza la conversión y a continuación se lee el resultado.<br>
<br>
El primero consiste en lanzar la secuencia <b>CCh 44h</b>. El byte CC, también llamado <i>SKIP ROM COMMAND</i> indica que no nos dirigimos a un dispositivo concreto, sino a cualquier esclavo en el bus.<br>
<br>
El byte 44h significa <i>CONVERT TEMPERATURE</i>. Tal como sugiere el nombre, el DS1820 seleccionado (en este caso todos) inicia la conversión a temperatura. Mientras efectúa la medida, el dispositivo indica que está ocupado devolviendo 0 a cualquier operación de lectura. Una vez termina, el DS1820 pasa a devolver 1.<br>
<br>
<pre class="cpp" name="code">/* Starts a temperature convertion and waits until it finish */<br>void convert_t (int pin) {<br> send_byte(pin, 0xCC);<br> send_byte(pin, 0x44);<br><br> while (read_byte(pin) != 0xFF)<br>  delayMicroseconds(20000);<br><br> reset(pin);<br>}<br></pre><br>
La lectura puede llevar hasta 500ms. En la rutina anterior lanzamos la conversión y esperamos, consultando la línea periódicamente hasta leer todo unos. Si estuviésemos usando la alimentación parásita, durante este tiempo no deberíamos lanzar comandos a otros dispositivos porque se interrumpiría la alimentación. Finalmente, como siempre, reiniciamos el bus.<br>
<br>
Tras la conversión, la temperatura queda guardada en el <b>scratchpad</b> y hemos de leerla de ahí. Si recordáis, el <i>scratchpad</i> es una especie de pizarra donde escribimos las alertas de temperatura y de donde leemos el resultado de la conversión. El comando BE se llama <i>READ SCRATCHPAD</i> y devuelve los 8 bytes del scratchpad más el correspondiente crc, 9 bytes en total.<br>
<br>
Lanzamos la secuencia <b>CC BE</b>. El comando CC, igual que antes, selecciona todos los esclavos conectados al bus. A diferencia del comando 44h <i>CONVERT TEMPERATURE</i>, con el que no había problema al invocar a todos los esclavos al mismo tiempo, si pedimos a todos los esclavos que vuelquen al bus el contenido de la memoria, el resultado va a ser desastroso. En nuestro caso podemos hacerlo así porque sólo hay uno.<br>
<br>
El siguiente código lanza la secuencia CC BE, lee nueve bytes, comprueba el CRC y finalmente reinicia el bus.<br>
<br>
<pre class="cpp" name="code">/* Reads the whole scratchpad to the buffer (9 bytes) */<br>int read_scratchpad(int pin, char *buff) {<br> send_byte(PIN, 0xCC);<br> send_byte(PIN, 0xBE);<br><br> int i;<br> for (i = 0; i &lt; 9; i++) {<br>  buff[i] = read_byte(PIN);<br>  printf("%02x ", buff[i]);<br> }<br>  <br> if (crc8(buff, 9)) {<br>  puts("\tScratchpad data read ERROR, try again.");<br> }<br> else {<br>  puts("\tOK");<br> }<br>  <br> reset(PIN);<br>}<br></pre><br>
El resultado leído es este:<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">22 00 4b 46 ff ff 09 10 c0 OK</span><br>
<br>
Aquí vemos el significado de cada byte según viene descrito en el datasheet:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/scratchpad.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/scratchpad.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Contenido del scratchpad. Datasheet DS1820. Dallas Semiconductor.</td>
</tr>
</tbody>
</table><br>
<br>
Los bytes 1º y 2º (numerados 0 y 1) indican la <b>temperatura</b> de un modo directo en grados centígrados. Para temperaturas positivas es muy sencillo interpretarlo: el primero da la temperatura con resolución de medio grado, y el segundo es cero. Para temperaturas negativas hay que interpretarlo de otra manera. El datasheet proporciona una tabla de conversión.<br>
<br>
Y por fin, ahora, en este momento, después de una hora leyendo, podemos decir que el byte 0 es 22h, que equivale a 34 decimal y que 34 medios grados son finalmente... <b>17.0ºC. ¡Sí! ¡Aleluya!</b>.<br>
<br>
Hay una forma de obtener más precisión. Fijaos en los últimos bytes, <i>COUNT REMAIN</i> y <i>COUNT PER °C</i>. ¿Os acordáis de cómo leía la temperatura el DS1820? ¿El oscilador que abría y cerraba la puerta? Bueno pues este último byte indica cuántos pulsos por grado centígrado se contabilizan a esta temperatura. En nuestro caso son 10h (16 en decimal). Cada 16 pulsos se suma un grado. El otro byte, indica el remanente, en otras palabras, cuántos pulsos quedaban para llegar al grado al término del periodo de medición. Nos ha dado 09h, equivalente a 9 en decimal.<br>
<br>
Si han quedado 9 pulsos hasta llegar a los 16, eso significa que habían entrado ya 7 pulsos. De ahí se puede deducir la temperatura con una precisión mayor. Para empezar olvidemos el medio grado de resolución quedándonos sólo con la parte entera. Y a continuación debemos aplicar la siguiente formula:<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/formula_temp.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/formula_temp.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Fórmula para calcular la temperatura. Datasheet DS1820. Dallas Semiconductor.</td>
</tr>
</tbody>
</table><br>
<br>
En nuestro caso arroja un resultado de 17.1875ºC, lo redondearemos a 17.19ºC.<br>
<br>
Nunca confundáis <b>precisión</b> con <b>exactitud</b>. La precisión es de 1/16 grados o 0.0625ºC. Pero los DS1820 tienen un error de hasta 0.5ºC. Más precisión nos puede servir para medir incrementos de temperatura menores, pero no nos dará una temperatura más exacta.<br>
<br>
<br>
<b>Función main y conclusiones</b><br>
<br>
Para terminar, estas son las cabeceras de nuestro programa:<br>
<br>
<pre class="cpp" name="code">#define PIN 7         /* Pin number */<br>#define TIMESLOT 90   /* 1-Wire time slot in us 60-120 */<br>#define TREC 2        /* Line pull up recovery time us */<br></pre><br>
Y a seguidamente la función <i>main</i>:<br>
<ol>
<li>Inicializa la librería WiringPi. Fija la prioridad máxima y configura los pines y las resistencias de pullup.</li>
<li>Reinicia el bus y espera confirmación por parte de algún esclavo. Si no hay nada escuchando termina el programa.</li>
<li>Lee la ROM e imprime por pantalla el resultado.</li>
<li>A continuación entra en el bucle principal. Donde ordena la conversión de temperatura, lee el scratchpad e imprime la temperatura leída. Usa la conversión de baja resolución y la de alta. Recordad, esta conversión sencilla sólo es válida para temperaturas <b>positivas</b>.</li>
</ol><br>
<pre class="cpp" name="code">int main (void)<br>{<br> puts ("DS1820 Test Program for Raspberry Pi");<br><br> if (wiringPiSetup () == -1)<br>  return 1;<br><br> piHiPri (99); /* us timing requires near real-time */<br> pinMode (PIN, INPUT);<br> pullUpDnControl (PIN, PUD_UP);<br><br> if (reset(PIN)) {<br>  puts ("Device present!");<br> }<br> else {<br>  puts ("Device not present, no response :(");<br>  return 1;<br> }<br><br> read_rom(PIN);<br><br> puts("Reading temperature:");<br> for (;;) {<br>  convert_t(PIN);<br><br>  char scratchpad[9];<br>  read_scratchpad(PIN, scratchpad);<br><br>  short int temp_read    = scratchpad[0];<br>  short int count_remain = scratchpad[6];<br>  short int count_per_c  = scratchpad[7];<br><br>  /* Low res temp */<br>  printf("Temperature (low res) is %.1fºC\n", (float)temp_read/2);<br><br>  /* High res temp */<br>  float temp_hr = (int) temp_read / 2;<br>  temp_hr = temp_hr - 0.25 + ((float)count_per_c - (float)count_remain) / (float)count_per_c;<br><br>  printf("COUNT_PER_C: %d, COUNT_REMAIN: %d\n", count_per_c, count_remain);<br>  printf("Temperature (hi res) is %.2fºC\n", temp_hr);<br> }<br><br> return 0;<br>}<br></pre><br>
Aquí podemos ver el resultado de la ejecución:<br>
<span style="font-size: small;"><br></span><br>
<pre><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span style="font-size: small;">$ sudo ./ds1820<br>DS1820 Test Program for Raspberry Pi<br>Device present!<br><br>Reading ROM data (Cmd 33h)<br>10 8c 67 e3 01 08 00 30         OK<br><br>Reading temperature:<br>22 00 4b 46 ff ff 0a 10 95      OK<br><br>Temperature (low res) is 17.0ºC<br><br>COUNT_PER_C: 16, COUNT_REMAIN: 10<br>Temperature (hi res) is 17.12ºC</span><br></span></pre><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br></span><br>
<br>
Es todo por ahora. <a href="https://www.dropbox.com/s/pyztfqt63qx3iys/ds1820_rpi.zip?dl=0">En este enlace</a> podéis encontrar los programas y archivos utilizados durante la elaboración del artículo, incluyendo:<br>
<ul>
<li>El programa principal ds1820.c</li>
<li>Los programas utilizados para los ejemplos de crc, benchmarks de funciones de espera, etc.<br></li>
<li>Imágenes. Datasheet del ds1820.</li>
<li style="list-style: none"><br></li>
</ul><br>
<br>
</div>
<div class='post-labels'>
Etiquetas:
<ul>
<li>linux</li>
<li>programacion</li>
<li>raspberrypi</li>
</ul>
</div><!-- Above is post content -->
</div><!-- content-inner -->
</div><!-- content-outer -->
<script src="../../../resources/script_bottom.js">
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
<link rel="stylesheet" href="../../../resources/style.css">
<script src="../../../resources/script.js">
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' type='text/javascript'>
MathJax.Hub.Config({
 extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
 jax: ["input/TeX", "output/HTML-CSS"],
 tex2jax: {
     inlineMath: [ ['$','$'], ['$$','$$'], ["\\(","\\)"] ],
     displayMath: [ ["\\[","\\]"] ],
 },
 "HTML-CSS": { availableFonts: ["TeX"] }
});
</script>
<title>El bus I2C a bajo nivel</title>
</head>
<body>
<div class="content-outer">
<div class="header">
<div class="title">
<h1>Electrónica y Ciencia</h1>
</div><!-- title -->
<div class="description">
<h2>Blog técnico sobre proyectos caseros de electrónica, informática y física.</h2>
</div><!-- description -->
</div><!-- header -->
<div class="content-inner">
<!-- Here the blog content -->
<h3 class='post-title entry-title'>El bus I2C a bajo nivel</h3>
<div class='post-date'>
Publicado el 25-02-2017.
</div>
<div class='post-body entry-content'>
Siendo de los protocolos más utilizados, para algunos aficionados el bus I2C continúa siendo gran interrogante hoy en día. Dada la buena recepción de la entrada anterior, titulada <a href="../../../2016/12/el-bus-1-wire-bajo-nivel/articulo.html">El bus 1-Wire a bajo nivel</a> vamos a hacer otra dedicada a I2C con todo detalle.<br>
<br>
Como la mejor forma de ver cómo funciona algo es practicándolo, he escrito unas funciones para emular un puerto I2C por software para Raspberry Pi utilizando por debajo las funciones de WiringPi. Los ficheros están <a href="https://electronicayciencia.github.io/wPi_soft_i2c/" target="_blank">en el github del blog</a> y poco a poco los iremos desgranando a lo largo de esta entrada.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/I2c_logo.svg.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/I2c_logo.svg.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Logo de I2C: Philips, ahora NXP semiconductor</td>
</tr>
</tbody>
</table><br>
<a name='more' id="more"></a><br>
A los que ya conocéis las generalidades del bus, permitidme dar un repaso rápido para encaminar el artículo antes de ir a las profundidades.<br>
<br>
A diferencia del 1-Wire, I2C tiene una <b>línea de reloj</b> dedicada. Eso quiere decir que el reloj lo controlamos nosotros. Y por eso no habrá problema si el tiempo de espera resulta ser 15us en lugar de 5us. Problema que sí se da en otros buses como 1-Wire.<br>
<br>
Además es relativamente <b>lento</b> en el modo estándar. La frecuencia habitual de I2C es 100kHz. Indica la máxima frecuencia a la cual el dispositivo puede trabajar con fiabilidad, pero no la mínima, y de hecho puede ser tan baja como queramos. Como luego veremos se trata de un arma de doble filo, pues de no incorporar un <em>timeout</em> propio, un dispositivo puede dejar <b>bloqueado</b> el bus entero.<br>
<br>
<br>
<b>Protocolo físico</b><br>
<br>
Empecemos por lo más general: sin contar la alimentación, el bus I2C consta de dos líneas de <em>colector abierto</em>.<br>
<br>
Se dice que una salida es de colector abierto cuando lo único que se puede hacer con ella es ponerla a masa o no. Es decir, tiene dos estados: al aire y 0 voltios. Se hace así para que no haya problema si dos dispositivos "hablan" simultáneamente. Lo único que pasará es que ambos pondrán la linea a masa a la vez. El mensaje llegará corrupto, sí, pero a nivel eléctrico no tiene mayor implicación. No provoca ningún cortocircuito.<br>
<br>
Como sólo podemos elegir si llevar la linea a nivel bajo o no, conectamos una resistencia de pull-up a positivo de alimentación. De esta forma la línea siempre está a nivel alto, salvo que algún terminal "tire" de ella y la lleve a 0. Cuando <i>la suelte</i> volverá a 1 de nuevo.<br>
<br>
El valor recomendado para las resistencias de pull-up está entre 1k y 10k, pero funcionará bien hasta 100k. El único impacto que realmente tiene el que la resistencia sea mayor o menor es el tiempo de recuperación. Tened en cuenta que los pines de los integrados tienen una capacidad parásita. Así como los cables del bus. Dicha capacidad es como si fuera una "bolsa" que debe llenarse de electrones antes de llegar a un nivel lógico 1. Y se llena a través de, precisamente, la resistencia de pull-up.<br>
<br>
Si la resistencia es muy grande, tardará más tiempo en alcanzar la tensión umbral de nivel alto (2.5 voltios en muchos casos). Si el tiempo de recuperación es demasiado grande no podemos conmutar la línea muy rápido o pondremos dos niveles bajos antes de que se hubiera alcanzado el nivel alto.<br>
<br>
Si la resistencia es pequeña, la recuperación será más rápida. Pero también sufrirán más los transistores de los integrados, pues les obligamos a soportar una mayor corriente para llevar a linea a masa. Estos transistores soportan 3mA según la especificación para los modos normal y estándar y hasta 20mA en chips que utilicen otros modos rápidos. A todo esto, la capacidad parásita de un bus I2C suele ser muy pequeña; de lo contrario podría haber problemas de comunicación cruzada entre SCL y SDA.<br>
<br>
El bus I2C, como decíamos, tiene dos líneas. Una llamada SCL y la otra SDA, para reloj y datos respectivamente. Todos los elementos que componen el protocolo físico se forman jugando con estas dos líneas. Vamos a repasar cuáles son estos elementos por encima, tendremos oportunidad de ampliarlos más adelante.<br>
<br>
Cuando el máster (o uno de los máster, ya lo veremos) inicia una conversación, lleva y mantiene las líneas en nivel bajo. Primero la línea de datos y luego la de reloj. Es lo que se llama condición de inicio, o simplemente <b>start</b>.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/start_stop.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/start_stop.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Señales de start y de stop. NXP Semiconductor.</td>
</tr>
</tbody>
</table><br>
A partir de este momento, <em>la linea de datos no puede cambiar de estado mientras el reloj esté en nivel alto</em>.<br>
<br>
Para transmitir un valor lógico debemos recordar dos cosas, una es que <em>el control de la línea de reloj siempre corresponde al maestro</em>, y otra que <em>el esclavo lee el estado de SDA durante el flanco de subida de SCL y lo fija durante el flanco de bajada del pulso de reloj inmediatamente anterior.</em>.<br>
<br>
Para transmitir un 1 o un 0 hacia el esclavo, el maestro libera la línea SDA o la mantiene a 0 y acto seguido sube y vuelve a bajar el reloj. Durante este pulso el esclavo ha leído el dato.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/data_valid.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/data_valid.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">La línea de datos solo puede cambiar con el reloj a novel bajo. NXP.</td>
</tr>
</tbody>
</table><br>
Para recibir un dato transmitido desde el esclavo, el maestro libera primero SCL. Luego libera SDA y la lee. Después vuelve a bajar SCL y SDA.<br>
<br>
Finalmente, el maestro realiza la secuencia inversa de start. Libera SCL y a continuación libera SDA. Esta condición es interpretada como reset por los dispositivos I2C conectados y se llama <em>stop</em> o condición de parada.<br>
<br>
Todo se entiende mejor con un pequeño ejemplo.<br>
<br>
<br>
<b>Emulación por software</b><br>
<br>
El I2C es uno de los buses que mejor se presta al <em>bit banging</em>. Se llama así a la práctica de emular por software bit a bit lo que normalmente haría un hardware dedicado.<br>
<br>
El bus tiene una linea de reloj dedicada. Eso lo simplifica todo muchísimo. Porque al contrario de lo que ocurría con 1-wire, donde los tiempos de espera eran críticos, <b>en I2C el tiempo <em>no existe</em></b>. El único tiempo que importa es el que marcamos nosotros mediante la linea SCL.<br>
<br>
Como os anticipaba, he escrito unas funciones para emular I2C por software en Raspberry Pi utilizando WiringPi y las he subido a un <a href="https://electronicayciencia.github.io/wPi_soft_i2c/">repositorio github</a>.<br>
<br>
Ni que decir tiene que estas rutinas sólo hacen un uso muy básico de WiringPi, tal como leer el valor de un pin, escribirlo, esperar un retardo o fijar las resistencias de pull-up. Por tanto sería un trabajo sencillo portarlas para utilizar otra librería diferente si se quisiera prescindir de WiringPi.<br>
<br>
Ahora, si os interesa, vamos a explicar paso a paso en qué consiste la emulación. Empezando por el fichero de cabeceras.<br>
<pre class="cpp" name="code">#ifndef _SOFT_I2C_H<br>#define _SOFT_I2C_H<br><br>#include &lt;stdint.h&gt;<br><br>#define I2C_READ   1<br>#define I2C_WRITE  0<br>#define I2C_ACK    0<br>#define I2C_NACK   1<br><br>#define I2C_FREQ 100000    /* I2C clock max frequency 100kHz */<br><br>typedef struct {<br> int scl;<br> int sda;<br>} i2c_t;<br></pre>Las dos primeras líneas que veis se llaman <em><a href="https://en.wikipedia.org/wiki/Include_guard">include guard</a></em> y están ahí para asegurar que la inclusión del fichero de cabeceras es una operación <i>idempotente</i>. En cristiano, que si por cualquier causa tratáramos de incluir el mismo fichero más de una vez, sólo se incluiría la primera.<br>
<br>
A continuación nos traemos el listado de tipos estándar entre los que consta el "número sin signo de 8 bits". En previsión de que un <b>char</b> pudiera cambiar de tamaño en otras arquitecturas, cosa harto improbable por otro lado.<br>
<br>
Ahora definimos unas constantes sencillas que harán más legible el código cuando usemos la librería. <b>I2C_READ</b> e <b>I2C_WRITE</b> se refieren al valor del bit menos significativo de la dirección. Cuando es 1 la operación será de lectura, y cuando es 0 será de escritura. Lo que significa en cada caso una operación de lectura o de escritura depende ya del dispositivo.<br>
<br>
Más abajo veremos que cuando el maestro o el esclavo reciben un byte, contestan con un bit de <b>acknowledge</b>. Cuando la confirmación es positiva el bit que envían es un 0 (tiran de la linea). Y si no envían un 0, es porque no han recibido correctamente. En tal caso la linea se va solita a nivel alto. Por esa razón la recepción satisfactoria se indica con un 0.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/ack.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/ack.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">Bit de ack tras la recepción de un byte. NXP Semiconductor.</td>
</tr>
</tbody>
</table>En la línea 11 definimos la frecuencia de trabajo, 100kHz. Este valor, más que guiar el reloj, influirá en los tiempos de retardo cuando cambiemos de estado una linea.<br>
<br>
Por último definimos una <b>estructura</b> de datos. Nos servirá para identificar el bus. En lugar de apuntar todo el tiempo cuales son las patillas de <b>SDA</b> y <b>SCL</b> en cada llamada, pasaremos como parámetro esta estructura.<br>
<br>
<br>
<b>Primitivas</b><br>
<br>
Tal como hicimos en la entrada anterior, iremos de la función más simple a la más complicada. En este caso, funciones que sólo interactúan con el hardware. Sólo estas funciones llaman a WiringPi, podríamos decir que hacen de drivers.<br>
<br>
Empiezan por subrayado indicando así que son funciones internas y no debe llamarlas el programa principal sino solamente otras funciones de la librería.<br>
<pre class="cpp" name="code">/* Pull: drives the line to level LOW */<br>void _i2c_pull(int pin) {<br> pinMode(pin, OUTPUT);<br> digitalWrite(pin, LOW);<br> delayMicroseconds((1e6/I2C_FREQ)/2);<br>}<br></pre>Empezaremos por la función más sencilla de entender: llevar la linea a <b>nivel bajo</b>. Poco hay que decir de esta función. Simplemente pone a nivel bajo el pin que se le pase como parámetro.<br>
<br>
Tras cambiar una linea de estado siempre esperamos un <b>semiperiodo</b>. Lo hacemos así por un lado para estabilizar el bus y por otro para dar tiempo a los esclavos a recibir el nuevo estado. Debido a esto, una subida y bajada consecutivas duran entre las dos un periodo completo de reloj. Y de ahí la frecuencia máxima de trabajo.<br>
<pre class="cpp" name="code">/* Release: releases the line and return line status */<br>int _i2c_release(int pin) {<br> pinMode(pin, INPUT);<br> delayMicroseconds((1e6/I2C_FREQ)/2);<br> return digitalRead(pin);<br>}<br></pre>La siguiente que veremos es la función contraria. Libera la línea para que vuelva a nivel alto. Para eso la pone como entrada, en estado de alta impedancia. Antes de salir espera -por la misma razón que antes- un semiperiodo.<br>
<br>
Pero a diferencia de la anterior, lee y devuelve el estado en que queda la linea realmente. Hay diversos motivos por los que al liberar una de las dos líneas, esta continúa en nivel bajo.<br>
<br>
Si la linea de datos no sube, puede ser por dos cosas. La primera, un esclavo está <b>transmitiendo</b>. Como los esclavos transmiten en el flanco de bajada del reloj anterior, un esclavo podría estar transmitiendo un <b>ACK</b> o un dato de una lectura anterior. Normalmente, como somos el master, sabemos cuándo esperamos la contestación de un esclavo. Si lo hace de forma inesperada indica un problema en el bus. Quizá un <b>pico de SCL</b> que se ha interpretado erróneamente como un pulso de reloj.<br>
<br>
La segunda causa, hay <b>otro máster</b> transmitiendo al mismo tiempo. Los másters preparados para <em>bus multi-master</em> monitorizan el bus en busca de señales de start y stop, y sólo empiezan a transmitir cuando tienen constancia de que no hay una conversación en curso. Pero si hay <b>dos masters</b> conectados al mismo bus, y empiezan a transmitir a la vez, la única forma que tienen de darse cuenta de ello es comprobando que las líneas tienen el valor que esperan en todo momento. En cuanto uno de los masters advierte un valor inesperado, deja de transmitir y lo reintenta más tarde. Se llama <em>I2C arbitration</em>. En esta versión de la emulación software <b>no</b> está incluida tal característica. También puede darse la situación de dos esclavos con la misma dirección transmitiendo a la vez, pero esta circunstancia es muy infrecuente.<br>
<br>
Para la línea de reloj, en cambio, hay una condición bien definida, llamada <em>clock stretching</em> que puede mantenerla en nivel bajo e impedir que suba. Hablaremos de esto en la siguiente rutina:<br>
<pre class="cpp" name="code">/* In case of clock stretching or busy bus we must wait */<br>void _i2c_release_wait(int pin) {<br> pinMode(pin, INPUT);<br> delayMicroseconds((1e6/I2C_FREQ)/2);<br> while (!digitalRead(pin))<br>  delayMicroseconds(100);<br> delayMicroseconds((1e6/I2C_FREQ)/2);<br>}<br></pre>Si la línea de reloj <b>no sube</b>, algún esclavo está tirando de ella para impedir que enviemos más datos. Esta circunstancia se llama <em>clock stretching</em> y es uno de los métodos usados por un esclavo para indicar que no admite más datos porque aún se está <b>procesando</b> el dato anterior. El esclavo mantiene la línea <b>SCL</b> baja impidiendo al master enviar más datos.<br>
<br>
En esta rutina ponemos la línea en estado de alta impedancia y luego esperamos a intervalos de 100us hasta que tome un valor lógico 1. Por tanto siempre retorna cuando la línea ya está libre.<br>
<br>
Un esclavo puede mantener el reloj abajo todo el tiempo que lo necesite, evitando cualquier transmisión en el bus. De hecho si uno de los dispositivos conectados al bus se <b>bloquea</b> en este estado, el bus queda inservible. Carecer de <em>timeout</em> es uno de los grandes problemas de I2C. Ya está <b>solventado</b> en, por ejemplo, SMBus.<br>
<br>
Otros dispositivos, como las <b>EEPROM</b>, actúan no contestando a su direccionamiento cuando están ocupados. Es como si no estuvieran para nadie. Así el máster sabe que no puede enviar más datos, pero el resto de dispositivos se comunican con normalidad.<br>
<br>
<br>
<b>Componentes lógicos</b><br>
<br>
Ya hemos visto las primitivas físicas del protocolo. Ahora vamos a utilizarlas para implementar los componentes del bus: señal de inicio, de parada, enviar datos y recibir datos.<br>
<br>
Empecemos por la función de <b>inicialización</b>:<br>
<pre class="cpp" name="code">/* Initializes software emulated i2c */<br>i2c_t i2c_init(int scl, int sda) {<br> i2c_t port;<br><br> port.scl = scl;<br> port.sda = sda;<br> <br> pinMode(scl, INPUT);<br> pinMode(sda, INPUT);<br> pullUpDnControl(scl, PUD_UP);<br> pullUpDnControl(sda, PUD_UP);<br><br> i2c_reset(port);<br><br> return port;<br>}<br></pre>Esta función recibe dos parámetros, el pin que se va a utilizar para <b>SCL</b> y el que se utilizaremos para <b>SDA</b>. Siguiendo la <b>numeración de WiringPi</b>. En ese orden. Con tales parámetros se compone una estructura de tipo <b>i2c_t</b>. Dicha estructura es la que utilizaremos para llamar al resto de funciones. De tal forma que podríamos definir con <b>i2c_init</b> tantos buses emulados como necesitemos.<br>
<br>
A continuación se configuran ambos pines como entradas y se activan las resistencias de pull-up. En Raspberry las resistencias de pull-up son de 50k. Aunque sobrepasan lo aconsejado para I2C servirán.<br>
<br>
Seguidamente llama a la función <b>i2c_reset</b>, por si el bus estuviera bloqueado por alguna condición de las que hablábamos antes. Esta función la veremos más adelante.<br>
<br>
Finalmente nos deja las líneas en nivel alto. El bus está libre. Para comenzar una comunicación el master debe lanzar una señal <b>start</b>. Como ya vimos, la señal de start consiste en bajar <b>SDA</b> mientras <b>SCL</b> está en nivel alto. Pero para que esto funcione, primero ambas líneas deben estar en nivel alto.<br>
<pre class="cpp" name="code">/* Start: pull SDA while SCL is up*/<br>/* Best practice is to ensure the bus is not busy before start */<br>void i2c_start(i2c_t port) {<br> if (!_i2c_release(port.sda)) <br>  i2c_reset(port);<br> _i2c_release_wait(port.scl);<br><br> _i2c_pull(port.sda);<br> _i2c_pull(port.scl);<br>}<br></pre>La función start se asegura antes de nada de que ambas líneas están en nivel alto. Podría no ser así por ejemplo en caso de un restart. Algunos dispositivos requieren una señal de start <b>sin</b> una señal previa de stop. Lo que implica que partimos con las lineas en nivel bajo.<br>
<br>
Primero tratará de levantar <b>SDA</b>. Quitando los casos <i>multimáster</i>, el único motivo por el que <b>SDA</b> no se levanta es que un esclavo esté transmitiendo, lo cual es un error inesperado. Si ocurre lanzamos llamamos a la función de reset automáticamente.<br>
<br>
A continuación levantamos <b>SCL</b>. Este caso es diferente, ya que no hay ninguna razón por la que un esclavo retenga el reloj más allá del clock stretching. Por eso en lugar de lazar reset si no levanta, lo que hacemos es esperar hasta que se libere.<br>
<br>
Fijaos que primero hemos liberado <b>SDA</b> y luego <b>SCL</b>, porque si lo hubiésemos hecho al contrario habríamos generado, sin quererlo, una señal de stop.<br>
<br>
Ahora, con las dos líneas en alto, tiramos de <b>SDA</b> y acto seguido de <b>SCL</b>. Ya hemos lanzado el <b>start</b>. Vamos a ver el stop.<br>
<pre class="cpp" name="code">/* Stop: release SDA while SCL is up */<br>void i2c_stop(i2c_t port) {<br> _i2c_release_wait(port.scl);<br> if (!_i2c_release(port.sda))<br>  i2c_reset(port);<br>}<br></pre>Este es el caso contrario, primero tenemos que levantar <b>SCL</b> y después <b>SDA</b>. Ahora sí partimos de que ambas líneas están abajo porque somos nosotros los que las estamos llevando a masa todo el rato.<br>
<br>
Así pues, levantamos <b>SCL</b> y si no levanta esperamos hasta que los esclavos terminen. Seguidamente liberamos <b>SDA</b> y si no levanta tal como esperamos llamamos a reset.<br>
<br>
El siguiente "bloque" para construir el protocolo es el envío de <b>un bit</b>.<br>
<pre class="cpp" name="code">/* Sends 0 or 1: <br> * Clock down, send bit, clock up, wait, clock down again <br> * In clock stretching, slave holds the clock line down in order<br> * to force master to wait before send more data */<br>void i2c_send_bit(i2c_t port, int bit) {<br> if (bit)<br>  _i2c_release(port.sda);<br> else<br>  _i2c_pull(port.sda);<br>  <br> _i2c_release_wait(port.scl);<br> _i2c_pull(port.scl);<br><br> _i2c_pull(port.sda);<br>}<br></pre>La transmisión es sencilla. Aquí no verificamos nada. Asumimos que las líneas están abajo porque siempre las dejamos así. Simplemente ponemos <b>SDA</b> al nivel que queramos transmitir, alto para 1, bajo para 0 y enviamos un <b>pulso</b> de reloj: es decir, subimos y volvemos a bajar <b>SCL</b>.<br>
<br>
Al levantar <b>SCL</b> utilizamos la función con espera por si estuviera ocupado, aunque no es lo habitual. Al terminar no olvidamos volver a dejar <b>SDA</b> en nivel bajo para el siguiente bit.<br>
<pre class="cpp" name="code">/* Reads a bit from sda */<br>int i2c_read_bit(i2c_t port) {<br> int s;<br><br> _i2c_release(port.sda);<br> _i2c_release(port.scl);<br> s = digitalRead(port.sda);<br> _i2c_pull(port.scl);<br> _i2c_pull(port.sda);<br> <br> return s;<br>}<br></pre>Para leer un bit primero liberamos <b>SDA</b>. Luego liberamos <b>SCL</b>. Y leemos cómo está <b>SDA</b>, ese será el valor leído. Volvemos a bajar ambas. Recordad que siempre movemos <b>SDA</b> estando <b>SCL</b> a nivel bajo, porque si lo hacemos al contrario se interpretará como una señal de start o stop.<br>
<br>
Una observación. Los esclavos escriben el estado en el flanco de bajada del clock anterior, por lo que el estado se podía leer antes de liberar <b>SCL</b>. En cualquier caso, como es algo que tenemos que hacer igualmente, no importa el orden.<br>
<br>
Bien, sabemos leer un bit y escribir un bit. Las funciones siguientes escriben <b>8 bits</b> y leen 8 bits utilizando las anteriores.<br>
<pre class="cpp" name="code">/* Sends 8 bit in a row, MSB first and reads ACK.<br> * Returns I2C_ACK if device ack'ed */<br>int i2c_send_byte(i2c_t port, uint8_t byte) {<br> int i;<br><br> for (i = 0; i &lt; 8; i++) {<br>  i2c_send_bit(port, byte & 0x80);<br>  byte = byte &lt;&lt; 1;<br> }<br><br> return i2c_read_bit(port);<br>}<br></pre>El protocolo exige que después de recibir cada byte el esclavo o el master confirmen con un bit 0. Por eso después de terminar el bucle de 8 bit, leemos un bit más para usarlo como valor devuelto. Si el bit es 0 el esclavo ha confirmado adecuadamente, si es 1 el esclavo no ha recibido el byte. En lugar de utilizar 0 y 1, es más legible usar las constantes <b>I2C_ACK</b> e <b>I2C_NACK</b> respectivamente.<br>
<br>
La comunicación I2C siempre se hace en bloques de 1 bit o de 1 byte. Se indican con 1 bit los mensajes de ACK o NACK, y con 1 byte el resto. Los bytes siempre se transmiten con el bit más significativo primero, al contrario que por ejemplo en 1-wire.<br>
<pre class="cpp" name="code">/* Reads a byte, MSB first */<br>uint8_t i2c_read_byte(i2c_t port) {<br> int byte = 0x00;<br> int i;<br><br> for (i=0; i &lt; 8; i++) <br>  byte = (byte &lt;&lt; 1) | i2c_read_bit(port);<br><br> return byte;<br>}<br></pre><br>
Esta función <b>no</b> envía ningún bit de acknowledge. Debemos llamar nosotros manualmente al envío del bit que queramos transmitir según las circunstancias.<br>
<br>
Antes de terminar con los elementos lógicos del protocolo vamos a dedicar un momento a hablar de la función de <b>reset</b>, también llamada <em>bus recovery sequence</em>.<br>
<pre class="cpp" name="code">/* Reset bus sequence */<br>void i2c_reset(i2c_t port) {<br> int i;<br><br> _i2c_release(port.sda);<br><br> do {<br>  for (i = 0; i &lt; 9; i++) {<br>   _i2c_pull(port.scl);<br>   _i2c_release(port.scl);<br>  }<br> } while (!digitalRead(port.sda));<br><br> _i2c_pull(port.scl);<br> _i2c_pull(port.sda);<br><br> i2c_stop(port);<br>}<br></pre>La misión de esta <b>secuencia</b> es liberar el bus en caso de que un esclavo esté transmitiendo en un momento inoportuno. Podría pasar si una conversación queda interrumpida inesperadamente o si un transitorio en <b>SCL</b> se interpreta erróneamente como un pulso de reloj.<br>
<br>
Primero <b>liberamos SDA</b> y seguidamente generamos 9 pulsos de reloj con <b>SDA</b> en alto. Los 8 primeros pulsos servirán al esclavo para transmitir el byte o parte del byte que le quedara. El noveno hará se interpretará por el esclavo como un bit 1, señal de <em>not acknowledge</em>, para indicar al esclavo el <b>fin</b> de la transmisión.<br>
<br>
Tras dicha secuencia, ambas líneas deben estar en nivel alto ya. De no ser así se repite.<br>
<br>
Con ambas líneas en alto las llevamos abajo, primero <b>SCL</b> y a continuación <b>SDA</b> para no enviar una señal de start sin querer. Y una vez ahí llamamos a la función <b>i2c_stop</b>. Después de este baile el bus debería quedar <b>operativo</b> de nuevo.<br>
<br>
Podría contaros cómo se compone una conversación I2C típica. Tienen todas un marco común pero cada integrado es un mundo, por tanto lo mejor será irlo viendo con ejemplos.<br>
<br>
<br>
<b>Direccionamiento y barrido</b><br>
<br>
De nuevo, para resaltar lo obvio, el bus I2C es un <b>bus</b>, y eso significa varios dispositivos conectados a los mismos cables. Al igual que en cualquier bus se necesita una forma de dirigirse a uno concreto de todos los dispositivos al alcance. En <b>1-wire</b> es una dirección única de 64 bit, en <b>SPI</b> es una línea física individual de Chip Select... En <b>I2C</b> cada dispositivo tiene una dirección de 7 bit, con una parte fija y -en muchos integrados de uso común- otra variable.<br>
<br>
Los 4 primeros bit de la dirección corresponden a lo que se llama el "<b>grupo</b>" de dispositivos. Pretende ser una especie de categoría, pero no vais a encontrar un criterio definido para la agrupación. Por ejemplo el grupo 7 (0111) agrupa chips relacionados con el manejo de LCD. El grupo 8 (1000), integrados para recepción de radio y televisión. El grupo A (1010) contiene memorias EEPROM, relojes o calendarios. El 9 (1001) contiene al ADC <b>PCF8591</b>, y también selectores de video, entre otros. El C (1100) agrupa integrados relacionados con RF (sintonizadores, PLL, etc).<br>
<br>
Hay dos grupos especiales: el 1111, que está reservado para utilizarlo en integrados que usan direcciones de 10 bit en lugar de las habituales de 7 bit; y el 0000 para broadcast.<br>
<br>
<b>No hay</b> una tabla actualizada donde estén todos los grupos y las direcciones asignadas. El motivo se puede entender desde el punto de vista del fabricante. Según NXP, si se hiciera pública la tabla de direcciones asignadas y libres cualquier fabricante de integrados podría escoger una dirección libre y apropiársela para sus chips. Puesto que el espacio de direcciones es muy limitado tal práctica va en contra del buen funcionamiento del protocolo.<br>
<br>
Pero sí hay una lista del año 1999... <a href="http://simplemachines.it/doc/IC12_97_I2C_ALLOCATION.pdf">http://simplemachines.it/doc/IC12_97_I2C_ALLOCATION.pdf</a><br>
<br>
Los <b>tres bits siguientes</b> pueden ser fijos o variables. Son variables en los dispositivos que admiten más de una unidad del mismo tipo en el bus. Por ejemplo las memorias serie tipo <b>24LCXXX</b> tienen tres bit variables. Lo cual permite que convivan hasta 8 en el mismo bus. Desde la 1010000 hasta la 1010111. Otros integrados sólo tienen dos bits variables, otros uno o ninguno.<br>
<br>
Sí, 7 bit es poco. Si lo comparamos con los <b>64bit</b> del bus 1-wire, por ejemplo, I2C está bastante más limitado en cuanto a direccionamiento. Sin embargo al transmitir menos datos se gana en velocidad. Hay integrados que admiten direccionamiento de 10 bit. Para esos la dirección siempre es 11110XX, y a continuación un segundo byte con los restantes 8 bit de dirección. 10 bits ofrecen 1024 posibilidades distintas.<br>
<br>
También hay <b>multiplexores</b> I2C, por ejemplo el <b>PCA9540</b> de dos canales. El funcionamiento es simple: entra un bus I2C y salen 2, como en cualquier multiplexor. Cualquiera de los dos buses pueden actuar como extensión del bus principal. Mediante un código de control se selecciona cual de los dos se quiere activar. Hay multiplexores con hasta 8 buses de salida.<br>
<br>
El <b>último bit</b> del byte de dirección indica la operación, será 1 para operaciones de <b>lectura</b> y 0 para <b>escritura</b>.<br>
<br>
Toda comunicación I2C comienza de la misma manera:<br>
<ul>
<li>El master envía una señal de start.</li>
<li>Envía la dirección del dispositivo con el último bit indicando la operación.</li>
<li>El dispositivo responde enviando un bit 0.</li>
</ul>El siguiente código de <b>ejemplo</b> inicializa un puerto I2C en los pines 23 y 24 (siempre numeración WiringPi). Después, para <b>todas</b> las direcciones posibles de 7 bit envía una señal de start, la dirección y acto seguido lee la respuesta. Si la respuesta es <b>I2C_ACK</b> es señal de que había algún dispositivo con tal dirección esperando. Después finaliza con stop y prueba la siguiente dirección.<br>
<pre class="cpp" name="code">i2c_t i2c = i2c_init(23,24);<br><br>for (addr = 0; addr &lt; 128; addr++) {<br> i2c_start(i2c);<br> if (i2c_send_byte(i2c, addr &lt;&lt; 1 | I2C_READ) == I2C_ACK)<br>  printf (" * Device found at %0xh\n", addr);<br> i2c_stop(i2c);<br>}<br></pre>La salida indica que tenemos una EEPROM escuchando en este bus.<br>
<br>
<pre>I2C scan for soft_i2c project<br> * Device found at 50h<br></pre><br>
Realizamos el barrido utilizando operaciones de lectura o de escritura. No es del todo fiable ni una ni otra, pues hay dispositivos a los que les puede sentar muy mal una operación de lectura o de escritura inapropiadas. Por ejemplo algunas memorias pueden empezar a transmitir datos tras escuchar su dirección en una operación de lectura. El programa <b>i2cdetect</b> utiliza read para algunos dispositivos y write para otros como se puede ver en <a href="https://github.com/groeck/i2c-tools/blob/master/tools/i2cdetect.c#L68">su código fuente</a>.<br>
<br>
<br>
<b>Conversación I2C</b><br>
<br>
Tras dirigirnos a un dispositivo enviando su dirección, este responderá. A continuación pueden pasar dos cosas en función de si la operación era de <b>lectura</b> (último bit a 1) o de <b>escritura</b> (último bit a 0).<br>
<br>
Si la operación era de escritura el chip normalmente espera más bytes que para él serán comandos. No hay un patrón, cada integrado tiene su propio protocolo especificado en el datasheet. Si la operación era de lectura, el chip normalmente empieza a transmitir datos.<br>
<br>
Veamos un ejemplo de uso. Si recordáis de una entrada anterior <a href="../../../2016/11/conexion-gpio-de-raspberry-pi-3/articulo.html">Conexión GPIO de Raspberry Pi 3</a>, el <b>PCF8591</b> es un <b>ADC</b> de 8 bit muy sencillo tipo <em><a href="https://en.wikipedia.org/wiki/Sample_and_hold">sample and hold</a></em> con 4 canales. El código fuente completo podéis verlo en <a href="https://github.com/electronicayciencia/wPi_soft_i2c/blob/master/pcf8591.c">Github</a>.<br>
<br>
Lo primero inicializar el bus I2C como habíamos dicho, indicando primero el pin para <b>SCL</b> y después el de <b>SDA</b>.<br>
<br>
<pre class="cpp" name="code">i2c_t i2c = i2c_init(9,8);<br></pre><br>
Recordad que en Raspberry Pi 3 los pines GPIO 8 y 9 (numeración wiringpi) tienen la función de I2C por <b>hardware</b>. Si lo tenéis habilitado es recomendable elegir otros pines o bien descargar los módulos I2C del kernel.<br>
<br>
Ahora vamos al datasheet del integrado -<a href="http://www.nxp.com/documents/data_sheet/PCF8591.pdf">disponible aquí</a>-. Lo primero que buscamos es su dirección I2C, <b>48h</b>.<br>
<br>
Para usarlo en modo ADC debemos empezar enviando el byte de control. Con este byte indicaremos cómo disponer las entradas y el canal que nos interesa leer.<br>
<br>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
<tbody>
<tr>
<td style="text-align: center;">
<a href="img/pcf8591_control.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="img/pcf8591_control.png"></a>
</td>
</tr>
<tr>
<td class="tr-caption" style="text-align: center;">
Byte de control en el PCF8591. <a href="http://www.nxp.com/documents/data_sheet/PCF8591.pdf" target="_blank">NXP</a>.
</td>
</tr>
</tbody>
</table><br>
Según el dibujo anterior:<br>
<br>
<ul>
<li>El <b>bit 8</b> siempre es 0.</li>
<li>Desactivamos la salida analógica porque ahora no nos interesa más que el modo ADC. <b>Séptimo</b> bit cero también.</li>
<li>Cuatro canales independientes. <b>Bits 6 y 5</b> ambos a 0.</li>
<li>El <b>bit 4</b> es 0 siempre.</li>
<li>Auto incrementar canal desactivado, <b>bit 3</b> también 0.</li>
<li>Finalmente nos interesa el canal 1. Así que bit 2 a 0 y bit 1 a 1.</li>
</ul><br>
El byte de configuración resultante debe valer 01h.<br>
<pre class="cpp" name="code">// Send control register<br>i2c_start(i2c);<br>i2c_send_byte(i2c, 0x48 &lt;&lt; 1 | I2C_WRITE);<br>i2c_send_byte(i2c, 1);<br>i2c_stop(i2c);<br></pre>Ahora el chip está <b>configurado</b>. Solo queda leer los datos. De nuevo según el datasheet basta con lanzar una operación de lectura para que empiece a transmitir.<br>
<br>
Eso sí, después de leer cada byte debemos confirmarlo enviando un bit a 0, de lo contrario dejará de enviar más lecturas.<br>
<pre class="cpp" name="code">// Read A/D values<br>i2c_start(i2c);<br>i2c_send_byte(i2c, 0x48 &lt;&lt; 1 | I2C_READ);<br><br>while(1) {<br> int byte = i2c_read_byte(i2c);<br> i2c_send_bit(i2c, I2C_ACK);<br> printf("-%d-\n", byte);<br> delayMicroseconds(10000);<br>}<br></pre>He puesto un retardo de 10ms para el ejemplo. Realmente no es necesario porque la velocidad de muestreo del ADC está limitada por la velocidad del bus I2C.<br>
<br>
Esta forma de leer el ADC es mucho más limpia, fiable y rápida que utilizando gpio como hacíamos en la otra entrada. La razón es que continúa activo y leyendo valores todo el tiempo en lugar de encenderse y apagarse con cada lectura.<br>
<br>
<br>
<b>Línea de comandos</b><br>
<br>
Y ya para terminar el artículo, he creído interesante contar con las funciones anteriores pero como programa interactivo para ensayar otros dispositivos I2C. No pego el código fuente, el fichero lo tenéis en Github: <a href="https://github.com/electronicayciencia/wPi_soft_i2c/blob/master/i2cli.c">i2cli.c</a>.<br>
<br>
La invocación es mediante la consola de comandos indicando, igual que para <b>i2c_init</b>, los puertos <b>SCL</b> y <b>SDA</b> en numeración wiringpi.<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br></span> <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">$ <b>./i2cli 9 8</b></span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">I2C Command Line Interface</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">I2C ready. SCL: 9, SDA: 8</span><br>
<br>
Admite los siguientes comandos:<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>s</b>: envía señal Start</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>p</b>: envía señal stoP</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>a</b>: envía un bit 0 (Ack)</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>n</b>: envía un bit 1 (Nak)</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>wHH</b>: envía el byte HH en hexadecimal y lee el ack</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>r</b>: recibe un byte, no envía ningún ack</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>q</b>: salir</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>C</b>: barre el bus en busca de dispositivos</span><br>
<br>
Por ejemplo, tenemos una EEPROM tipo 24lc128. Su dirección habitual es entre el 50h y el 53h.<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; C</b></span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">* Device found at 50h (R: a1, W: a0)</span><br>
<br>
Nos indica que, siendo la dirección 50h, para una operación de <b>lectura</b> debemos enviar A1h (50h más un bit a 1) y para escritura A0h.<br>
<br>
Vamos a escribir los valores <b>5b</b> y <b>5c</b> por ejemplo, en la <b>dirección</b> 0001h. Para lo cual escribimos la dirección del chip, a continuación la dirección de memoria y seguidamente los datos. Al terminal mandamos un stop para finalizar la operación. En ese momento la EEPROM guarda los datos y durante unos 5ms su dirección I2C no contesta.<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; s</b> ; start</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; wa0</b> ; 50h -&gt; escritura</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">a0 -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; w00</b> ; address MSB 00h</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">00 -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; w00</b> ; address LSB 01h</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">00 -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; w5b</b> ; write 0001: 5b</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">5b -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; w5c</b> ; write 0002: 5c</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">5c -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; p</b> ; stop</span><br>
<br>
Ahora vamos a leer el valor escrito en la dirección <b>0002h</b>, que debe ser 5c. Para esto, según el datasheet, debemos lanzar la operación primero como si fuera una escritura y escribir los dos bytes de la dirección desde la que queremos leer:<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; s</b> ; start</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; wa0</b> ; 50h write</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">a0 -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; w00</b> ; address MSB 00h</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">00 -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; w02</b> ; address LSB 02h</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">02 -&gt; ACK</span><br>
<br>
Pero a diferencia de antes, ahora no enviamos datos, sino que continuación, sin lanzar un stop, debemos enviar de nuevo el start. Y proceder como si la operación fuera de <b>lectura</b>. Leyendo tantos bytes como deseemos desde la dirección solicitada en adelante.<br>
<br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; s</b> ; restart</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; wa1</b> ; 50h read</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">a1 -&gt; ACK</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; r</b> ; read byte</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">5c ; byte in 0002: 5c</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; p</b> ; ack</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt; q</b> ; quit</span><br>
<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>i2cli&gt;</b> Bye!</span><br>
<br>
<br>
Nada más por ahora. Si os interesa el tema, os dejo un documento comparando tipos de buses en especial I2C: <a href="http://www.nxp.com/documents/customer_presentation/design_con_2003_tecforum_i2c_bus_overview.pdf">http://www.nxp.com/documents/customer_presentation/design_con_2003_tecforum_i2c_bus_overview.pdf</a><br>
<br>
El manual de las funciones lo podéis encontrar en <a href="https://electronicayciencia.github.io/wPi_soft_i2c/">https://electronicayciencia.github.io/wPi_soft_i2c/</a>.<br>
<br>
Los archivos utilizados para elaborar este artículo están en el repositorio <a href="https://github.com/electronicayciencia/wPi_soft_i2c">https://github.com/electronicayciencia/wPi_soft_i2c</a><br>
<br>
<br>
</div>
<div class='post-labels'>
Etiquetas:
<ul>
<li>microcontroladores</li>
<li>programacion</li>
<li>raspberrypi</li>
</ul>
</div><!-- Above is post content -->
</div><!-- content-inner -->
</div><!-- content-outer -->
<script src="../../../resources/script_bottom.js">
</script>
</body>
</html>
